/*------------------------------------------------------------------------------
 * gint.c : GNSS orbit functions

 * author  : sujinglan
 * version : $Revision: 1.1 $ $Date: 2008/07/17 21:48:06 $
 * Copyright(c) 2023-2025 by sujinglan, all rights reserved
 * history : 2024/10/17 1.0  new
 *-----------------------------------------------------------------------------*/
#include "podlib.h"
#include "nrlmsise-00.h"
#include "eopspw.h"
#include "gsl/ode-initval2/gsl_odeiv2.h"
#include "gsl/err/gsl_errno.h"
#include "boost/odeint.h"

/* polar angle-----------------------------------------------------------------*/
static void polarang(const double *rv, double *pa)
{
    double s=SQR(rv[0])+SQR(rv[1]);
    double r=sqrt(s+SQR(rv[2]));
    pa[0]=pa[1]=0.0;

    if (fabs(rv[0])<1E-10&&fabs(rv[1])<1E-10) pa[0]=0.0;
    else pa[0]=atan2(rv[1],rv[0]);

    if (pa[0]<0.0) pa[0]+=2*PI;

    if (fabs(rv[2])<1E-10&&fabs(sqrt(s))<1E-10) pa[1]=0.0;
    else pa[1]=atan2(rv[2],sqrt(s));
}
/* atmospheric density for the modified Harris-Priester model------------------*/
static double atmdenshpm(const atmospheric_drag_t *ad, double mjd, const double *erpv, const double *rsun, const double *rs)
{
    static const double hpcoef[10][177]={
            {1.10000E+02, 7.80000E+01, 7.80000E+01, 1.20000E+02, 2.49000E+01, 2.49000E+01, 1.30000E+02, 8.97800E+00, 9.33100E+00, 1.40000E+02, 4.06900E+00, 4.21200E+00, 1.50000E+02, 2.08600E+00, 2.16800E+00, 1.60000E+02, 1.14600E+00, 1.23600E+00, 1.70000E+02, 6.61600E-01, 7.55800E-01, 1.80000E+02, 4.01600E-01, 4.88500E-01, 1.90000E+02, 2.53000E-01, 3.27400E-01, 2.00000E+02, 1.62800E-01, 2.28400E-01, 2.10000E+02, 1.07600E-01, 1.63400E-01, 2.20000E+02, 7.28700E-02, 1.19200E-01, 2.30000E+02, 5.03800E-02, 8.85100E-02, 2.40000E+02, 3.54900E-02, 6.66600E-02, 2.50000E+02, 2.54100E-02, 5.08300E-02, 2.60000E+02, 1.84600E-02, 3.91900E-02, 2.70000E+02, 1.35800E-02, 3.05000E-02, 2.80000E+02, 1.01000E-02, 2.39400E-02, 2.90000E+02, 7.58800E-03, 1.89400E-02, 3.00000E+02, 5.71900E-03, 1.51000E-02, 3.20000E+02, 3.30500E-03, 9.88600E-03, 3.40000E+02, 1.95300E-03, 6.60800E-03, 3.60000E+02, 1.17500E-03, 4.49400E-03, 3.80000E+02, 7.16700E-04, 3.10000E-03, 4.00000E+02, 4.42800E-04, 2.16300E-03, 4.20000E+02, 2.77900E-04, 1.52600E-03, 4.40000E+02, 1.76000E-04, 1.08500E-03, 4.60000E+02, 1.12800E-04, 7.76700E-04, 4.80000E+02, 7.34600E-05, 5.59900E-04, 5.00000E+02, 4.86600E-05, 4.06100E-04, 5.20000E+02, 3.29100E-05, 2.96300E-04, 5.40000E+02, 2.27900E-05, 2.17400E-04, 5.60000E+02, 1.62200E-05, 1.60500E-04, 5.80000E+02, 1.18800E-05, 1.19200E-04, 6.00000E+02, 8.97800E-06, 8.91000E-05, 6.20000E+02, 6.98700E-06, 6.70800E-05, 6.40000E+02, 5.59300E-06, 5.09000E-05, 6.60000E+02, 4.58900E-06, 3.89600E-05, 6.80000E+02, 3.84600E-06, 3.01100E-05, 7.00000E+02, 3.28100E-06, 2.35100E-05, 7.20000E+02, 2.83800E-06, 1.85700E-05, 7.40000E+02, 2.48200E-06, 1.48400E-05, 7.60000E+02, 2.19000E-06, 1.20200E-05, 7.80000E+02, 1.94400E-06, 9.85700E-06, 8.00000E+02, 1.73600E-06, 8.19300E-06, 8.50000E+02, 1.18000E-06, 6.20000E-06, 9.00000E+02, 8.70000E-07, 4.40000E-06, 9.50000E+02, 6.60000E-07, 3.30000E-06, 1.00000E+03, 4.80000E-07, 2.70000E-06, 1.10000E+03, 3.00000E-07, 1.75000E-06, 1.20000E+03, 1.85000E-07, 1.20000E-06, 1.30000E+03, 1.13000E-07, 8.50000E-07, 1.40000E+03, 7.30000E-08, 6.20000E-07, 1.50000E+03, 5.20000E-08, 4.75000E-07, 1.60000E+03, 3.70000E-08, 3.65000E-07, 1.70000E+03, 2.55000E-08, 3.00000E-07, 1.80000E+03, 1.82000E-08, 2.20000E-07, 1.90000E+03, 1.30000E-08, 1.80000E-07, 2.00000E+03, 1.00000E-08, 1.45000E-07},
            {1.10000E+02, 7.80000E+01, 7.80000E+01, 1.20000E+02, 2.49000E+01, 2.49000E+01, 1.30000E+02, 8.91300E+00, 9.26300E+00, 1.40000E+02, 4.05100E+00, 4.19700E+00, 1.50000E+02, 2.09200E+00, 2.17600E+00, 1.60000E+02, 1.16000E+00, 1.24900E+00, 1.70000E+02, 6.78100E-01, 7.69700E-01, 1.80000E+02, 4.15700E-01, 5.01600E-01, 1.90000E+02, 2.65300E-01, 3.39100E-01, 2.00000E+02, 1.72500E-01, 2.38100E-01, 2.10000E+02, 1.15100E-01, 1.71600E-01, 2.20000E+02, 7.86600E-02, 1.26200E-01, 2.30000E+02, 5.48500E-02, 9.43500E-02, 2.40000E+02, 3.89400E-02, 7.15500E-02, 2.50000E+02, 2.81000E-02, 5.49200E-02, 2.60000E+02, 2.05600E-02, 4.26100E-02, 2.70000E+02, 1.52300E-02, 3.33700E-02, 2.80000E+02, 1.14100E-02, 2.63500E-02, 2.90000E+02, 8.63100E-03, 2.09600E-02, 3.00000E+02, 6.55400E-03, 1.68200E-02, 3.20000E+02, 3.84000E-03, 1.11300E-02, 3.40000E+02, 2.30100E-03, 7.51400E-03, 3.60000E+02, 1.40300E-03, 5.16000E-03, 3.80000E+02, 8.68400E-04, 3.59500E-03, 4.00000E+02, 5.44000E-04, 2.53400E-03, 4.20000E+02, 3.41900E-04, 1.79800E-03, 4.40000E+02, 2.18900E-04, 1.29100E-03, 4.60000E+02, 1.41800E-04, 9.33400E-04, 4.80000E+02, 9.30400E-05, 6.79500E-04, 5.00000E+02, 6.19400E-05, 4.97600E-04, 5.20000E+02, 4.19500E-05, 3.66400E-04, 5.40000E+02, 2.89900E-05, 2.71300E-04, 5.60000E+02, 2.05000E-05, 2.01900E-04, 5.80000E+02, 1.48700E-05, 1.51100E-04, 6.00000E+02, 1.10900E-05, 1.13700E-04, 6.20000E+02, 8.50000E-06, 8.61400E-05, 6.40000E+02, 6.69900E-06, 6.56700E-05, 6.60000E+02, 5.41600E-06, 5.04300E-05, 6.80000E+02, 4.47900E-06, 3.90300E-05, 7.00000E+02, 3.77700E-06, 3.04700E-05, 7.20000E+02, 3.23800E-06, 2.40200E-05, 7.40000E+02, 2.81200E-06, 1.91300E-05, 7.60000E+02, 2.46800E-06, 1.54000E-05, 7.80000E+02, 2.18400E-06, 1.25400E-05, 8.00000E+02, 1.94500E-06, 1.03300E-05, 8.50000E+02, 1.40000E-06, 7.30000E-06, 9.00000E+02, 1.00000E-06, 5.20000E-06, 9.50000E+02, 7.80000E-07, 3.80000E-06, 1.00000E+03, 5.80000E-07, 3.10000E-06, 1.10000E+03, 3.55000E-07, 2.05000E-06, 1.20000E+03, 2.30000E-07, 1.40000E-06, 1.30000E+03, 1.45000E-07, 1.00000E-06, 1.40000E+03, 9.10000E-08, 7.20000E-07, 1.50000E+03, 6.70000E-08, 5.45000E-07, 1.60000E+03, 4.50000E-08, 4.15000E-07, 1.70000E+03, 3.30000E-08, 3.40000E-07, 1.80000E+03, 2.25000E-08, 2.65000E-07, 1.90000E+03, 1.60000E-08, 2.10000E-07, 2.00000E+03, 1.28000E-08, 1.70000E-07},
            {1.10000E+02, 7.80000E+01, 7.80000E+01, 1.20000E+02, 2.49000E+01, 2.49000E+01, 1.30000E+02, 8.74000E+00, 9.09100E+00, 1.40000E+02, 4.00200E+00, 4.15700E+00, 1.50000E+02, 2.10300E+00, 2.19100E+00, 1.60000E+02, 1.19500E+00, 1.28300E+00, 1.70000E+02, 7.18600E-01, 8.06900E-01, 1.80000E+02, 4.51500E-01, 5.35300E-01, 1.90000E+02, 2.95700E-01, 3.69500E-01, 2.00000E+02, 1.98000E-01, 2.63800E-01, 2.10000E+02, 1.35400E-01, 1.93800E-01, 2.20000E+02, 9.45900E-02, 1.45200E-01, 2.30000E+02, 6.73700E-02, 1.10500E-01, 2.40000E+02, 4.88000E-02, 8.52700E-02, 2.50000E+02, 3.58900E-02, 6.65700E-02, 2.60000E+02, 2.67500E-02, 5.25000E-02, 2.70000E+02, 2.01700E-02, 4.17700E-02, 2.80000E+02, 1.53800E-02, 3.34900E-02, 2.90000E+02, 1.18300E-02, 2.70500E-02, 3.00000E+02, 9.11700E-03, 2.20200E-02, 3.20000E+02, 5.52200E-03, 1.49600E-02, 3.40000E+02, 3.42100E-03, 1.03600E-02, 3.60000E+02, 2.15800E-03, 7.29800E-03, 3.80000E+02, 1.38200E-03, 5.21000E-03, 4.00000E+02, 8.95200E-04, 3.76300E-03, 4.20000E+02, 5.86300E-04, 2.74400E-03, 4.40000E+02, 3.87500E-04, 2.01900E-03, 4.60000E+02, 2.58400E-04, 1.49700E-03, 4.80000E+02, 1.73900E-04, 1.11700E-03, 5.00000E+02, 1.18200E-04, 8.38200E-04, 5.20000E+02, 8.12300E-05, 6.32400E-04, 5.40000E+02, 5.65000E-05, 4.79400E-04, 5.60000E+02, 3.98700E-05, 3.65100E-04, 5.80000E+02, 2.85900E-05, 2.79300E-04, 6.00000E+02, 2.08800E-05, 2.14600E-04, 6.20000E+02, 1.55600E-05, 1.65600E-04, 6.40000E+02, 1.18500E-05, 1.28400E-04, 6.60000E+02, 9.23000E-06, 1.00000E-04, 6.80000E+02, 7.35100E-06, 7.83000E-05, 7.00000E+02, 5.98200E-06, 6.16200E-05, 7.20000E+02, 4.96500E-06, 4.87900E-05, 7.40000E+02, 4.19500E-06, 3.88600E-05, 7.60000E+02, 3.60000E-06, 3.11700E-05, 7.80000E+02, 3.13000E-06, 2.51800E-05, 8.00000E+02, 2.75100E-06, 2.05000E-05, 8.50000E+02, 2.00000E-06, 1.30000E-05, 9.00000E+02, 1.50000E-06, 9.00000E-06, 9.50000E+02, 1.20000E-06, 6.20000E-06, 1.00000E+03, 9.40000E-07, 5.00000E-06, 1.10000E+03, 5.80000E-07, 3.10000E-06, 1.20000E+03, 3.75000E-07, 2.10000E-06, 1.30000E+03, 2.50000E-07, 1.50000E-06, 1.40000E+03, 1.70000E-07, 1.10000E-06, 1.50000E+03, 1.18000E-07, 7.70000E-07, 1.60000E+03, 8.20000E-08, 6.00000E-07, 1.70000E+03, 6.00000E-08, 5.00000E-07, 1.80000E+03, 4.30000E-08, 3.90000E-07, 1.90000E+03, 3.20000E-08, 3.10000E-07, 2.00000E+03, 2.40000E-08, 2.50000E-07},
            {1.10000E+02, 7.80000E+01, 7.80000E+01, 1.20000E+02, 2.49000E+01, 2.49000E+01, 1.30000E+02, 8.56700E+00, 8.92000E+00, 1.40000E+02, 3.95200E+00, 4.11300E+00, 1.50000E+02, 2.11100E+00, 2.20200E+00, 1.60000E+02, 1.22600E+00, 1.31400E+00, 1.70000E+02, 7.57200E-01, 8.41100E-01, 1.80000E+02, 4.86400E-01, 5.67200E-01, 1.90000E+02, 3.25500E-01, 3.98900E-01, 2.00000E+02, 2.24300E-01, 2.88900E-01, 2.10000E+02, 1.56700E-01, 2.15900E-01, 2.20000E+02, 1.11800E-01, 1.64400E-01, 2.30000E+02, 8.11500E-02, 1.27200E-01, 2.40000E+02, 5.98700E-02, 9.97800E-02, 2.50000E+02, 4.47900E-02, 7.91300E-02, 2.60000E+02, 3.39400E-02, 6.33600E-02, 2.70000E+02, 2.60000E-02, 5.11600E-02, 2.80000E+02, 2.01100E-02, 4.16300E-02, 2.90000E+02, 1.57000E-02, 3.40900E-02, 3.00000E+02, 1.23100E-02, 2.80900E-02, 3.20000E+02, 7.67500E-03, 1.95300E-02, 3.40000E+02, 4.89400E-03, 1.38500E-02, 3.60000E+02, 3.17800E-03, 9.97600E-03, 3.80000E+02, 2.09400E-03, 7.28200E-03, 4.00000E+02, 1.39700E-03, 5.37600E-03, 4.20000E+02, 9.62500E-04, 4.03300E-03, 4.40000E+02, 6.55200E-04, 3.03400E-03, 4.60000E+02, 4.49700E-04, 2.29900E-03, 4.80000E+02, 3.10900E-04, 1.75400E-03, 5.00000E+02, 2.16600E-04, 1.34600E-03, 5.20000E+02, 1.52000E-04, 1.03800E-03, 5.40000E+02, 1.07600E-04, 8.04300E-04, 5.60000E+02, 7.68500E-05, 6.26000E-04, 5.80000E+02, 5.54500E-05, 4.89200E-04, 6.00000E+02, 4.04700E-05, 3.83800E-04, 6.20000E+02, 2.99200E-05, 3.02200E-04, 6.40000E+02, 2.24400E-05, 2.38800E-04, 6.60000E+02, 1.71000E-05, 1.89400E-04, 6.80000E+02, 1.32500E-05, 1.50700E-04, 7.00000E+02, 1.04500E-05, 1.20400E-04, 7.20000E+02, 8.39700E-06, 9.65800E-05, 7.40000E+02, 6.86700E-06, 7.77700E-05, 7.60000E+02, 5.71300E-06, 6.28900E-05, 7.80000E+02, 4.83000E-06, 5.10900E-05, 8.00000E+02, 4.14300E-06, 4.17000E-05, 8.50000E+02, 3.15000E-06, 2.70000E-05, 9.00000E+02, 2.25000E-06, 1.80000E-05, 9.50000E+02, 1.72000E-06, 1.20000E-05, 1.00000E+03, 1.40000E-06, 8.80000E-06, 1.10000E+03, 8.50000E-07, 5.30000E-06, 1.20000E+03, 5.40000E-07, 3.20000E-06, 1.30000E+03, 3.80000E-07, 2.25000E-06, 1.40000E+03, 2.80000E-07, 1.50000E-06, 1.50000E+03, 1.95000E-07, 1.03000E-06, 1.60000E+03, 1.35000E-07, 8.00000E-07, 1.70000E+03, 1.02000E-07, 6.50000E-07, 1.80000E+03, 7.40000E-08, 5.20000E-07, 1.90000E+03, 5.60000E-08, 4.25000E-07, 2.00000E+03, 4.40000E-08, 3.40000E-07},
            {1.10000E+02, 7.80000E+01, 7.80000E+01, 1.20000E+02, 2.49000E+01, 2.49000E+01, 1.30000E+02, 8.37700E+00, 8.71000E+00, 1.40000E+02, 3.89900E+00, 4.05900E+00, 1.50000E+02, 2.12200E+00, 2.21500E+00, 1.60000E+02, 1.26300E+00, 1.34400E+00, 1.70000E+02, 8.00800E-01, 8.75800E-01, 1.80000E+02, 5.28300E-01, 6.01000E-01, 1.90000E+02, 3.61700E-01, 4.29700E-01, 2.00000E+02, 2.55700E-01, 3.16200E-01, 2.10000E+02, 1.83900E-01, 2.39600E-01, 2.20000E+02, 1.34100E-01, 1.85300E-01, 2.30000E+02, 9.94900E-02, 1.45500E-01, 2.40000E+02, 7.48800E-02, 1.15700E-01, 2.50000E+02, 5.70900E-02, 9.30800E-02, 2.60000E+02, 4.40300E-02, 7.55500E-02, 2.70000E+02, 3.43000E-02, 6.18200E-02, 2.80000E+02, 2.69700E-02, 5.09500E-02, 2.90000E+02, 2.13900E-02, 4.22600E-02, 3.00000E+02, 1.70800E-02, 3.52600E-02, 3.20000E+02, 1.09900E-02, 2.51100E-02, 3.40000E+02, 7.21400E-03, 1.81900E-02, 3.60000E+02, 4.82400E-03, 1.33700E-02, 3.80000E+02, 3.27400E-03, 9.95500E-03, 4.00000E+02, 2.24900E-03, 7.49200E-03, 4.20000E+02, 1.55800E-03, 5.68400E-03, 4.40000E+02, 1.09100E-03, 4.35500E-03, 4.60000E+02, 7.70100E-04, 3.36200E-03, 4.80000E+02, 5.47400E-04, 2.61200E-03, 5.00000E+02, 3.91600E-04, 2.04200E-03, 5.20000E+02, 2.81900E-04, 1.60500E-03, 5.40000E+02, 2.04200E-04, 1.26700E-03, 5.60000E+02, 1.48800E-04, 1.00500E-03, 5.80000E+02, 1.09200E-04, 7.99700E-04, 6.00000E+02, 8.07000E-05, 6.39000E-04, 6.20000E+02, 6.01200E-05, 5.12300E-04, 6.40000E+02, 4.51900E-05, 4.12100E-04, 6.60000E+02, 3.43000E-05, 3.32500E-04, 6.80000E+02, 2.63200E-05, 2.69100E-04, 7.00000E+02, 2.04300E-05, 2.18500E-04, 7.20000E+02, 1.60700E-05, 1.77900E-04, 7.40000E+02, 1.28100E-05, 1.45200E-04, 7.60000E+02, 1.03600E-05, 1.19000E-04, 7.80000E+02, 8.49600E-06, 9.77600E-05, 8.00000E+02, 7.06900E-06, 8.05900E-05, 8.50000E+02, 4.80000E-06, 5.50000E-05, 9.00000E+02, 3.30000E-06, 3.70000E-05, 9.50000E+02, 2.45000E-06, 2.40000E-05, 1.00000E+03, 1.90000E-06, 1.70000E-05, 1.10000E+03, 1.18000E-06, 8.70000E-06, 1.20000E+03, 7.50000E-07, 4.80000E-06, 1.30000E+03, 5.30000E-07, 3.20000E-06, 1.40000E+03, 4.10000E-07, 2.00000E-06, 1.50000E+03, 2.90000E-07, 1.35000E-06, 1.60000E+03, 2.00000E-07, 9.50000E-07, 1.70000E+03, 1.60000E-07, 7.70000E-07, 1.80000E+03, 1.20000E-07, 6.30000E-07, 1.90000E+03, 9.60000E-08, 5.20000E-07, 2.00000E+03, 7.30000E-08, 4.40000E-07},
            {1.10000E+02, 7.80000E+01, 7.80000E+01, 1.20000E+02, 2.49000E+01, 2.49000E+01, 1.30000E+02, 8.23900E+00, 8.57700E+00, 1.40000E+02, 3.85800E+00, 4.02100E+00, 1.50000E+02, 2.12300E+00, 2.21800E+00, 1.60000E+02, 1.28300E+00, 1.36300E+00, 1.70000E+02, 8.24600E-01, 8.99700E-01, 1.80000E+02, 5.53800E-01, 6.25100E-01, 1.90000E+02, 3.84800E-01, 4.51400E-01, 2.00000E+02, 2.76000E-01, 3.36200E-01, 2.10000E+02, 2.01900E-01, 2.56900E-01, 2.20000E+02, 1.49500E-01, 2.00800E-01, 2.30000E+02, 1.12400E-01, 1.59300E-01, 2.40000E+02, 8.57900E-02, 1.28000E-01, 2.50000E+02, 6.62600E-02, 1.04000E-01, 2.60000E+02, 5.17400E-02, 8.52200E-02, 2.70000E+02, 4.07900E-02, 7.04100E-02, 2.80000E+02, 3.24400E-02, 5.85800E-02, 2.90000E+02, 2.60000E-02, 4.90400E-02, 3.00000E+02, 2.08700E-02, 4.13100E-02, 3.20000E+02, 1.36800E-02, 2.99100E-02, 3.40000E+02, 9.15700E-03, 2.20100E-02, 3.60000E+02, 6.23800E-03, 1.64300E-02, 3.80000E+02, 4.31300E-03, 1.24100E-02, 4.00000E+02, 3.01900E-03, 9.47500E-03, 4.20000E+02, 2.13400E-03, 7.29300E-03, 4.40000E+02, 1.52300E-03, 5.66500E-03, 4.60000E+02, 1.09600E-03, 4.43300E-03, 4.80000E+02, 7.93400E-04, 3.49100E-03, 5.00000E+02, 5.78200E-04, 2.76600E-03, 5.20000E+02, 4.23700E-04, 2.20300E-03, 5.40000E+02, 3.12200E-04, 1.76300E-03, 5.60000E+02, 2.31300E-04, 1.41700E-03, 5.80000E+02, 1.72300E-04, 1.14300E-03, 6.00000E+02, 1.29000E-04, 9.25800E-04, 6.20000E+02, 9.72400E-05, 7.52300E-04, 6.40000E+02, 7.37400E-05, 6.13300E-04, 6.60000E+02, 5.63100E-05, 5.01400E-04, 6.80000E+02, 4.33400E-05, 4.11100E-04, 7.00000E+02, 3.36300E-05, 3.38000E-04, 7.20000E+02, 2.63400E-05, 2.78700E-04, 7.40000E+02, 2.08400E-05, 2.30300E-04, 7.60000E+02, 1.66600E-05, 1.90800E-04, 7.80000E+02, 1.34700E-05, 1.58500E-04, 8.00000E+02, 1.10300E-05, 1.32000E-04, 8.50000E+02, 7.80000E-06, 9.20000E-05, 9.00000E+02, 5.10000E-06, 6.30000E-05, 9.50000E+02, 3.45000E-06, 4.10000E-05, 1.00000E+03, 2.60000E-06, 2.85000E-05, 1.10000E+03, 1.60000E-06, 1.40000E-05, 1.20000E+03, 1.00000E-06, 7.40000E-06, 1.30000E+03, 7.00000E-07, 4.30000E-06, 1.40000E+03, 5.43000E-07, 2.60000E-06, 1.50000E+03, 4.00000E-07, 1.70000E-06, 1.60000E+03, 2.90000E-07, 1.20000E-06, 1.70000E+03, 2.30000E-07, 9.40000E-07, 1.80000E+03, 1.75000E-07, 7.40000E-07, 1.90000E+03, 1.40000E-07, 6.00000E-07, 2.00000E+03, 1.09000E-07, 5.20000E-07},
            {1.10000E+02, 7.80000E+01, 7.80000E+01, 1.20000E+02, 2.49000E+01, 2.49000E+01, 1.30000E+02, 8.06800E+00, 8.38100E+00, 1.40000E+02, 3.81100E+00, 3.96400E+00, 1.50000E+02, 2.13000E+00, 2.22200E+00, 1.60000E+02, 1.31300E+00, 1.38600E+00, 1.70000E+02, 8.56800E-01, 9.27800E-01, 1.80000E+02, 5.93700E-01, 6.53100E-01, 1.90000E+02, 4.23800E-01, 4.77200E-01, 2.00000E+02, 3.10000E-01, 3.59900E-01, 2.10000E+02, 2.29700E-01, 2.77800E-01, 2.20000E+02, 1.73200E-01, 2.19400E-01, 2.30000E+02, 1.32600E-01, 1.75900E-01, 2.40000E+02, 1.02900E-01, 1.42800E-01, 2.50000E+02, 8.07300E-02, 1.17100E-01, 2.60000E+02, 6.39800E-02, 9.68900E-02, 2.70000E+02, 5.11700E-02, 8.08000E-02, 2.80000E+02, 4.12400E-02, 6.78400E-02, 2.90000E+02, 3.34900E-02, 5.73500E-02, 3.00000E+02, 2.73500E-02, 4.88500E-02, 3.20000E+02, 1.83800E-02, 3.59500E-02, 3.40000E+02, 1.26000E-02, 2.68700E-02, 3.60000E+02, 8.77800E-03, 2.03500E-02, 3.80000E+02, 6.20500E-03, 1.56000E-02, 4.00000E+02, 4.44100E-03, 1.20700E-02, 4.20000E+02, 3.21000E-03, 9.41700E-03, 4.40000E+02, 2.34300E-03, 7.41100E-03, 4.60000E+02, 1.72300E-03, 5.87400E-03, 4.80000E+02, 1.27600E-03, 4.68600E-03, 5.00000E+02, 9.50600E-04, 3.76000E-03, 5.20000E+02, 7.12200E-04, 3.03300E-03, 5.40000E+02, 5.36200E-04, 2.45800E-03, 5.60000E+02, 4.05700E-04, 2.00100E-03, 5.80000E+02, 3.08300E-04, 1.63500E-03, 6.00000E+02, 2.35400E-04, 1.34100E-03, 6.20000E+02, 1.80500E-04, 1.10400E-03, 6.40000E+02, 1.39000E-04, 9.11400E-04, 6.60000E+02, 1.07600E-04, 7.54700E-04, 6.80000E+02, 8.37200E-05, 6.26700E-04, 7.00000E+02, 6.54900E-05, 5.21800E-04, 7.20000E+02, 5.15300E-05, 4.35500E-04, 7.40000E+02, 4.08000E-05, 3.64300E-04, 7.60000E+02, 3.25300E-05, 3.05500E-04, 7.80000E+02, 2.61300E-05, 2.56700E-04, 8.00000E+02, 2.11600E-05, 2.16200E-04, 8.50000E+02, 1.30000E-05, 1.40000E-04, 9.00000E+02, 7.90000E-06, 9.40000E-05, 9.50000E+02, 5.00000E-06, 6.40000E-05, 1.00000E+03, 3.50000E-06, 4.40000E-05, 1.10000E+03, 2.10000E-06, 2.20000E-05, 1.20000E+03, 1.30000E-06, 1.10000E-05, 1.30000E+03, 9.00000E-07, 6.20000E-06, 1.40000E+03, 6.80000E-07, 3.60000E-06, 1.50000E+03, 5.00000E-07, 2.25000E-06, 1.60000E+03, 3.70000E-07, 1.55000E-06, 1.70000E+03, 3.00000E-07, 1.20000E-06, 1.80000E+03, 2.32000E-07, 9.00000E-07, 1.90000E+03, 1.82000E-07, 7.30000E-07, 2.00000E+03, 1.45000E-07, 6.00000E-07},
            {1.10000E+02, 7.80000E+01, 7.80000E+01, 1.20000E+02, 2.49000E+01, 2.49000E+01, 1.30000E+02, 7.95600E+00, 8.26200E+00, 1.40000E+02, 3.77700E+00, 3.92900E+00, 1.50000E+02, 2.12800E+00, 2.22100E+00, 1.60000E+02, 1.32400E+00, 1.39700E+00, 1.70000E+02, 8.78200E-01, 9.44800E-01, 1.80000E+02, 6.11900E-01, 6.70500E-01, 1.90000E+02, 4.38000E-01, 4.93800E-01, 2.00000E+02, 3.23000E-01, 3.75100E-01, 2.10000E+02, 2.44100E-01, 2.91300E-01, 2.20000E+02, 1.86800E-01, 2.31700E-01, 2.30000E+02, 1.44500E-01, 1.87000E-01, 2.40000E+02, 1.13300E-01, 1.52800E-01, 2.50000E+02, 8.97600E-02, 1.26200E-01, 2.60000E+02, 7.18200E-02, 1.05100E-01, 2.70000E+02, 5.79500E-02, 8.82000E-02, 2.80000E+02, 4.71300E-02, 7.45200E-02, 2.90000E+02, 3.85000E-02, 6.34700E-02, 3.00000E+02, 3.15400E-02, 5.43900E-02, 3.20000E+02, 2.15200E-02, 4.04800E-02, 3.40000E+02, 1.49600E-02, 3.05900E-02, 3.60000E+02, 1.05700E-02, 2.34200E-02, 3.80000E+02, 7.56900E-03, 1.81300E-02, 4.00000E+02, 5.48700E-03, 1.41700E-02, 4.20000E+02, 4.01400E-03, 1.11600E-02, 4.40000E+02, 2.96700E-03, 8.86300E-03, 4.60000E+02, 2.21000E-03, 7.09000E-03, 4.80000E+02, 1.65700E-03, 5.70700E-03, 5.00000E+02, 1.25100E-03, 4.62000E-03, 5.20000E+02, 9.48900E-04, 3.75900E-03, 5.40000E+02, 7.23600E-04, 3.07400E-03, 5.60000E+02, 5.54300E-04, 2.52400E-03, 5.80000E+02, 4.26400E-04, 2.08100E-03, 6.00000E+02, 3.29400E-04, 1.72200E-03, 6.20000E+02, 2.55500E-04, 1.43000E-03, 6.40000E+02, 1.98900E-04, 1.19100E-03, 6.60000E+02, 1.55500E-04, 9.95000E-04, 6.80000E+02, 1.22100E-04, 8.33500E-04, 7.00000E+02, 9.63100E-05, 7.00000E-04, 7.20000E+02, 7.63000E-05, 5.89300E-04, 7.40000E+02, 6.07400E-05, 4.97300E-04, 7.60000E+02, 4.86200E-05, 4.20600E-04, 7.80000E+02, 3.91300E-05, 3.56400E-04, 8.00000E+02, 3.16900E-05, 3.02700E-04, 8.50000E+02, 2.00000E-05, 2.00000E-04, 9.00000E+02, 1.20000E-05, 1.35000E-04, 9.50000E+02, 7.70000E-06, 9.30000E-05, 1.00000E+03, 5.10000E-06, 6.80000E-05, 1.10000E+03, 2.80000E-06, 3.40000E-05, 1.20000E+03, 1.68000E-06, 1.70000E-05, 1.30000E+03, 1.10000E-06, 9.40000E-06, 1.40000E+03, 8.10000E-07, 5.20000E-06, 1.50000E+03, 6.00000E-07, 3.20000E-06, 1.60000E+03, 4.50000E-07, 2.20000E-06, 1.70000E+03, 3.60000E-07, 1.60000E-06, 1.80000E+03, 2.80000E-07, 1.20000E-06, 1.90000E+03, 2.25000E-07, 9.10000E-07, 2.00000E+03, 1.78000E-07, 7.20000E-07},
            {1.10000E+02, 7.80000E+01, 7.80000E+01, 1.20000E+02, 2.49000E+01, 2.49000E+01, 1.30000E+02, 7.83200E+00, 8.12100E+00, 1.40000E+02, 3.74200E+00, 3.88500E+00, 1.50000E+02, 2.13000E+00, 2.22000E+00, 1.60000E+02, 1.34000E+00, 1.41000E+00, 1.70000E+02, 9.00400E-01, 9.62400E-01, 1.80000E+02, 6.35000E-01, 6.88900E-01, 1.90000E+02, 4.61200E-01, 5.11900E-01, 2.00000E+02, 3.44000E-01, 3.90400E-01, 2.10000E+02, 2.62700E-01, 3.06400E-01, 2.20000E+02, 2.04000E-01, 2.45100E-01, 2.30000E+02, 1.59700E-01, 1.99100E-01, 2.40000E+02, 1.26600E-01, 1.63800E-01, 2.50000E+02, 1.01400E-01, 1.36000E-01, 2.60000E+02, 8.19600E-02, 1.14000E-01, 2.70000E+02, 6.67900E-02, 9.62700E-02, 2.80000E+02, 5.48200E-02, 8.19500E-02, 2.90000E+02, 4.50800E-02, 7.02500E-02, 3.00000E+02, 3.72700E-02, 6.05300E-02, 3.20000E+02, 2.58600E-02, 4.55400E-02, 3.40000E+02, 1.82700E-02, 3.47700E-02, 3.60000E+02, 1.31000E-02, 2.68900E-02, 3.80000E+02, 9.51900E-03, 2.10100E-02, 4.00000E+02, 6.99700E-03, 1.65800E-02, 4.20000E+02, 5.19100E-03, 1.31700E-02, 4.40000E+02, 3.88900E-03, 1.05600E-02, 4.60000E+02, 2.93600E-03, 8.51800E-03, 4.80000E+02, 2.23200E-03, 6.91500E-03, 5.00000E+02, 1.70800E-03, 5.64500E-03, 5.20000E+02, 1.31400E-03, 4.63100E-03, 5.40000E+02, 1.01500E-03, 3.81800E-03, 5.60000E+02, 7.88500E-04, 3.16100E-03, 5.80000E+02, 6.14900E-04, 2.62700E-03, 6.00000E+02, 4.81300E-04, 2.19200E-03, 6.20000E+02, 3.78200E-04, 1.83500E-03, 6.40000E+02, 2.98200E-04, 1.54100E-03, 6.60000E+02, 2.36000E-04, 1.29800E-03, 6.80000E+02, 1.87400E-04, 1.09600E-03, 7.00000E+02, 1.49400E-04, 9.28100E-04, 7.20000E+02, 1.19500E-04, 7.87800E-04, 7.40000E+02, 9.59500E-05, 6.70200E-04, 7.60000E+02, 7.73500E-05, 5.71400E-04, 7.80000E+02, 6.26200E-05, 4.88100E-04, 8.00000E+02, 5.09200E-05, 4.17900E-04, 8.50000E+02, 3.10000E-05, 2.70000E-04, 9.00000E+02, 1.80000E-05, 1.80000E-04, 9.50000E+02, 1.15000E-05, 1.30000E-04, 1.00000E+03, 7.60000E-06, 9.60000E-05, 1.10000E+03, 3.80000E-06, 5.10000E-05, 1.20000E+03, 2.10000E-06, 2.50000E-05, 1.30000E+03, 1.32000E-06, 1.40000E-05, 1.40000E+03, 9.40000E-07, 8.10000E-06, 1.50000E+03, 7.00000E-07, 5.00000E-06, 1.60000E+03, 5.20000E-07, 3.45000E-06, 1.70000E+03, 4.10000E-07, 2.40000E-06, 1.80000E+03, 3.30000E-07, 1.62000E-06, 1.90000E+03, 2.60000E-07, 1.20000E-06, 2.00000E+03, 2.10000E-07, 9.40000E-07},
            {1.10000E+02, 7.80000E+01, 7.80000E+01, 1.20000E+02, 2.49000E+01, 2.49000E+01, 1.30000E+02, 7.71700E+00, 7.98400E+00, 1.40000E+02, 3.71000E+00, 3.84100E+00, 1.50000E+02, 2.13200E+00, 2.21500E+00, 1.60000E+02, 1.35500E+00, 1.42000E+00, 1.70000E+02, 9.20700E-01, 9.77500E-01, 1.80000E+02, 6.56300E-01, 7.05200E-01, 1.90000E+02, 4.83100E-01, 5.28000E-01, 2.00000E+02, 3.64400E-01, 4.06400E-01, 2.10000E+02, 2.81300E-01, 3.20100E-01, 2.20000E+02, 2.21000E-01, 2.57400E-01, 2.30000E+02, 1.75000E-01, 2.10200E-01, 2.40000E+02, 1.40200E-01, 1.73700E-01, 2.50000E+02, 1.13500E-01, 1.45100E-01, 2.60000E+02, 9.27400E-02, 1.22200E-01, 2.70000E+02, 7.61300E-02, 1.03800E-01, 2.80000E+02, 6.27900E-02, 8.89100E-02, 2.90000E+02, 5.21000E-02, 7.65600E-02, 3.00000E+02, 4.34600E-02, 6.62500E-02, 3.20000E+02, 3.06700E-02, 5.02600E-02, 3.40000E+02, 2.20100E-02, 3.86900E-02, 3.60000E+02, 1.60200E-02, 3.01500E-02, 3.80000E+02, 1.18100E-02, 2.37500E-02, 4.00000E+02, 8.80400E-03, 1.88700E-02, 4.20000E+02, 6.62000E-03, 1.51100E-02, 4.40000E+02, 5.02500E-03, 1.21900E-02, 4.60000E+02, 3.84400E-03, 9.90600E-03, 4.80000E+02, 2.96100E-03, 8.09100E-03, 5.00000E+02, 2.29500E-03, 6.65400E-03, 5.20000E+02, 1.78800E-03, 5.49700E-03, 5.40000E+02, 1.40000E-03, 4.56100E-03, 5.60000E+02, 1.10200E-03, 3.80100E-03, 5.80000E+02, 8.70200E-04, 3.18000E-03, 6.00000E+02, 6.90000E-04, 2.67100E-03, 6.20000E+02, 5.49100E-04, 2.25100E-03, 6.40000E+02, 4.38400E-04, 1.90200E-03, 6.60000E+02, 3.51200E-04, 1.61300E-03, 6.80000E+02, 2.82200E-04, 1.37100E-03, 7.00000E+02, 2.27500E-04, 1.16900E-03, 7.20000E+02, 1.84000E-04, 9.98400E-04, 7.40000E+02, 1.49200E-04, 8.55000E-04, 7.60000E+02, 1.21400E-04, 7.33800E-04, 7.80000E+02, 9.91200E-05, 6.31000E-04, 8.00000E+02, 8.11900E-05, 5.43700E-04, 8.50000E+02, 4.40000E-05, 3.65000E-04, 9.00000E+02, 2.70000E-05, 2.40000E-04, 9.50000E+02, 1.70000E-05, 1.75000E-04, 1.00000E+03, 1.15000E-05, 1.30000E-04, 1.10000E+03, 5.30000E-06, 7.30000E-05, 1.20000E+03, 2.65000E-06, 3.80000E-05, 1.30000E+03, 1.55000E-06, 2.20000E-05, 1.40000E+03, 1.08000E-06, 1.35000E-05, 1.50000E+03, 8.00000E-07, 8.40000E-06, 1.60000E+03, 5.80000E-07, 5.80000E-06, 1.70000E+03, 4.65000E-07, 3.80000E-06, 1.80000E+03, 3.65000E-07, 2.40000E-06, 1.90000E+03, 2.90000E-07, 1.70000E-06, 2.00000E+03, 2.30000E-07, 1.25000E-06}
    };
    const double upper_limit=  2000.0;  /* upper height limit [km] */
    const double lower_limit=   100.0;  /* lower height limit [km] */
    const double ra_lag     =0.523599;  /* right ascension lag [rad] */
    const int    n_prm      =       4;  /* Harris-Priester parameter, 2(6) low(high) inclination */
    const int    F107       =     175;  /* solar radio noise flux */

    double h[256];
    double cmin[256],cmax[256];
    int i,j,k,N=59,ih=0;

    switch (F107) {
        case 65 : j=0; break;
        case 75 : j=1; break;
        case 100: j=2; break;
        case 125: j=3; break;
        case 150: j=4; break;
        case 175: j=5; break;
        case 200: j=6; break;
        case 225: j=7; break;
        case 250: j=8; break;
        case 275: j=9; break;
    }
    for (k=0,i=0;i<177;i+=3) h[k++]=hpcoef[j][i];
    for (k=0,i=1;i<177;i+=3) cmin[k++]=hpcoef[j][i];
    for (k=0,i=2;i<177;i+=3) cmax[k++]=hpcoef[j][i];

    double pos[3],pa[2],u[3],c,hmin,hmax,dmin,dmax,density;
    ecef2pos(rs,pos);

    if (pos[2]/1E3>upper_limit||pos[2]/1E3<lower_limit) return 0.0;
    
    polarang(rsun,pa);
    u[0]=cos(pa[1])*cos(pa[0]+ra_lag);
    u[1]=cos(pa[1])*sin(pa[0]+ra_lag);
    u[2]=sin(pa[1]);
    c=0.5+0.5*dot(rs,u,3)/norm(rs,3);

    for (i=0;i<N-1;i++) {
        if (pos[2]/1E3>=h[i]&&pos[2]/1E3<h[i+1]) {
            ih=i; break;
        }
    }
    hmin=(h[ih]-h[ih+1])/log(cmin[ih+1]/cmin[ih]);
    hmax=(h[ih]-h[ih+1])/log(cmax[ih+1]/cmax[ih]);
    dmin=cmin[ih]*exp((h[ih]-pos[2]/1E3)/hmin);
    dmax=cmax[ih]*exp((h[ih]-pos[2]/1E3)/hmax);
    density=(dmin+(dmax-dmin)*(pow(c,n_prm)))*1E-9;
    return density;
}
/* atmospheric density for the modified nrlmsise-00 model----------------------*/
static double atmdensnrl(const atmospheric_drag_t *ad, double mjd, const double *erpv, const double *rsun, const double *rs)
{
    struct nrlmsise_input input={0};
    struct nrlmsise_output output={0};
    struct nrlmsise_flags flags={0};
    struct ap_array aph={0};
    spw_t *spw=&ad->fmdl->spw;

    double ep[6],pos[3],T[3][3];
    const double mjd0=2400000.5;
    char interp,fluxtype,f81type,inputtype;
    double jd,mfme,f107a,f107,f107bar,ap,avgap,kp,sumkp,aparr[8],kparr[8];
    double sum,sec,lst,days,mjd_ut1,mjd_tt,gast;
    int i,j;

#if 0
    jd=floor(mjd)+mjd0;
    mfme=1440.0*(mjd-floor(mjd));
    interp='n';
    fluxtype='a';
    f81type='c';
    inputtype='a';
    findatmosparam(jd,mfme,interp,fluxtype,f81type,inputtype,gspwarr,gjdspwstart,&f107,&f107bar,&ap,&avgap,aparr,&kp,&sumkp,kparr);

    input.f107A=f107bar; /* centered 81-day arithmetic average of F10.7 (observed). */
    input.ap=avgap;      /* arithmetic average of the 8 AP indices for the day */
    aph.a[0]=avgap;      /* arithmetic average of the 8 AP indices for the day */
    aph.a[1]=aparr[0];   /* 3 hr Ap index for current time */
    mfme=mfme-1;
    fluxtype='o';
    findatmosparam(jd-1,mfme,interp,fluxtype,f81type,inputtype,gspwarr,gjdspwstart,&f107,&f107bar,&ap,&avgap,aparr,&kp,&sumkp,kparr);

    input.f107=f107;   /* daily F10.7 flux for previous day (observed). */
    aph.a[2]=aparr[7]; /* 3 hr AP index for 3 hrs before current time */
    aph.a[3]=aparr[6]; /* 3 hr AP index for 6 hrs before current time */
    aph.a[4]=aparr[5]; /* 3 hr AP index for 9 hrs before current time */
    sum=aparr[4]+aparr[3]+aparr[2]+aparr[1]+aparr[0];
    mfme=mfme-1;
    findatmosparam(jd-2,mfme,interp,fluxtype,f81type,inputtype,gspwarr,gjdspwstart,&f107,&f107bar,&ap,&avgap,aparr,&kp,&sumkp,kparr);

    sum=sum+aparr[7]+aparr[6]+aparr[5];
    aph.a[5]=sum/8.0;
    sum=aparr[4]+aparr[3]+aparr[2]+aparr[1]+aparr[0];
    mfme=mfme-1;
    findatmosparam(jd-3,mfme,interp,fluxtype,f81type,inputtype,gspwarr,gjdspwstart,&f107,&f107bar,&ap,&avgap,aparr,&kp,&sumkp,kparr);

    sum=sum+aparr[7]+aparr[6]+aparr[5];
    aph.a[6]=sum/8.0;
    input.ap_a=&aph;

    mjd_tt=mjdtt(mjd,erpv);
    mjd_ut1=mjdut1(mjd,erpv);
    mjd2cal(mjd,ep);

    days=doy(ep);
    ecef2pos(rs,pos);

    iauPnm06a(mjd0,mjd_tt,T);
    gast=iauGst06(mjd0,mjd_ut1,mjd0,mjd_tt,T);

    lst=pos[1]+gast;
    lst=fmod(lst,2.0*PI);
    if (lst<0.0) lst=lst+2.0*PI;
    lst=(lst*24.0)/(2.0*PI);

    flags.switches[0]=0;
    for (i=1;i<24;i++) flags.switches[i]=1;
    flags.switches[9]=-1;

    input.doy=floor(days);
    input.year=0; /* without effect */
    input.sec=ep[3]*3600.0+ep[4]*60.0+ep[5]; /* seconds in day (UT) */
    input.alt=pos[2]/1000.0;
    input.g_lat=pos[0]*R2D;
    input.g_long=pos[1]*R2D;
    input.lst=lst; /* local apparent solar time (hours), see note below */
#else
    mjd_tt=mjdtt(mjd,erpv);
    mjd_ut1=mjdut1(mjd,erpv);
    mjd2cal(mjd,ep);

    days=doy(ep);
    ecef2pos(rs,pos);

    iauPnm06a(mjd0,mjd_tt,T);
    gast=iauGst06(mjd0,mjd_ut1,mjd0,mjd_tt,T);

    lst=pos[1]+gast;
    lst=fmod(lst,2.0*PI);
    if (lst<0.0) lst=lst+2.0*PI;
    lst=(lst*24.0)/(2.0*PI);

    flags.switches[0]=0;
    for (i=1;i<24;i++) flags.switches[i]=1;
    flags.switches[9]=-1;

    for (j=-1,i=0;i<spw->n;i++) {
        if (spw->data[i].year==(int)ep[0]&&
            spw->data[i].mon ==(int)ep[1]&&
            spw->data[i].day ==(int)ep[2]) {
            j=i; break;
        }
    }
    if (j<2) return 0;

    /* centered 81-day arithmetic average of F10.7 (observed). */
    /* arithmetic average of the 8 AP indices for the day */
    /* arithmetic average of the 8 AP indices for the day */
    /* 3 hr Ap index for current time */

    /* daily F10.7 flux for previous day (observed). */
    /* 3 hr AP index for 3 hrs before current time */
    /* 3 hr AP index for 6 hrs before current time */
    /* 3 hr AP index for 9 hrs before current time */
    input.ap_a=&aph;
    input.ap=spw->data[j].avgap;
    input.ap_a->a[0]=spw->data[j].avgap;
    input.ap_a->a[1]=spw->data[j].aparr[0];
    input.ap_a->a[2]=spw->data[j-1].aparr[7];
    input.ap_a->a[3]=spw->data[j-1].aparr[6];
    input.ap_a->a[4]=spw->data[j-1].aparr[5];

    sum=spw->data[j-1].aparr[4]+spw->data[j-1].aparr[3]+spw->data[j-1].aparr[2]+spw->data[j-1].aparr[1]+spw->data[j-1].aparr[0];
    sum=spw->data[j-2].aparr[7]+spw->data[j-2].aparr[6]+spw->data[j-2].aparr[5]+sum;
    input.ap_a->a[5]=sum/8.0;

    sum=spw->data[j-2].aparr[4]+spw->data[j-2].aparr[3]+spw->data[j-2].aparr[2]+spw->data[j-2].aparr[1]+spw->data[j-2].aparr[0];
    sum=spw->data[j-3].aparr[7]+spw->data[j-3].aparr[6]+spw->data[j-3].aparr[5]+sum;
    input.ap_a->a[6]=sum/8.0;
    input.f107=spw->data[j-1].obsf10;
    input.f107A=spw->data[j-1].adjctrf81;

    input.doy=floor(days);
    input.year=0; /* without effect */
    input.sec=ep[3]*3600.0+ep[4]*60.0+ep[5]; /* seconds in day (UT) */
    input.alt=pos[2]/1000.0;
    input.g_lat=pos[0]*R2D;
    input.g_long=pos[1]*R2D;
    input.lst=lst; /* local apparent solar time (hours), see note below */
#endif
    gtd7d(&input,&flags,&output);
    return (output.d[5]*1.0E3); /* [kg/m^3] */
}
/* computes atmospheric density------------------------------------------------*/
static double atmdens(const atmospheric_drag_t *ad, int opt, double mjd, const double *erpv, const double *rsun, const double *rs)
{
    switch (opt) {
        case ATMODENSITY_HPM: return atmdenshpm(ad,mjd,erpv,rsun,rs);
        case ATMODENSITY_NRL: return atmdensnrl(ad,mjd,erpv,rsun,rs);
    }
}
/* conical shadow model-------------------------------------------------------*/
static double shadowconical(gtime_t tutc, const double *rsun, const double *rsunssb, const double *rmoon, const double *rearth, const double *rs)
{
    const double R_E=6378137.0;
    const double R_S=696000000.0;
    double s[3],d[3],sm,dm,a,b,c,nu,x,y,A;
    int i;

    for (i=0;i<3;i++) s[i]=rs[i]-rearth[i];
    for (i=0;i<3;i++) d[i]=rsun[i]-rs[i];
    sm=norm(s,3);
    dm=norm(d,3);
    a=asin(R_S/dm);
    b=asin(R_E/sm);
    c=acos(-1.0*dot(s,d,3)/(sm*dm));

    if (c>=a+b) {
        nu=1.0; /* in sun-light */
    }
    else if (c<fabs(a-b)) {
        nu=0.0; /* in umbra */
    }
    else { /* in penumbra */
        x=(SQR(c)+SQR(a)-SQR(b))/(2.0*c);
        y=sqrt(SQR(a)-SQR(x));
        A=SQR(a)*acos(x/a)+SQR(b)*acos((c-x)/b)-c*y;
        nu=1.0-A/(PI*SQR(a));
    }
    return nu;
}
/* fraction of sun's disk visible (1.0=no eclipse,0=total eclipse)------------*/
static double getlambda(const double rs, const double rp, const double sep)
{
    double lambda=0.0,r1,r2,phi,hgt,a1,a2,a3,theta,a;

    /* rs: apparent radius of sun as viweed from sattellite (radians)
     * rp: apparent radius of eclipsing body as viewed from satellite (radians)
     * sep: apparent seperation of center of sun and eclipsing body (radians)
     */
    if (rs+rp<=sep) {
        return 1.0; /* no eclipse */
    }
    else if (rp-rs>=sep) {
        return 0.0; /* full eclipse */
    }
    else {
        /* partial eclipse, compute eclipse's factor */
        if (sep>(rs-rp)) {
            r1=MIN(rp,rs);
            r2=MAX(rp,rs);

            /* 1/2 angle subtended in disc 1 by arc of intersection */
            phi=acos(r1*r1+sep*sep-r2*r2)/(2.0*r1*sep);
            if (phi<0.0) phi=PI+phi;

            if (r2/r1<=5.0) {
                /* hgt: 1/2 linear distance between ends of arc of intersection */
                /* theta: 1/2 angle subtended in disc 2 by arc of intersection */
                hgt=r1*sin(phi);
                theta=asin(hgt/r2);
                a2=sep*hgt;
                a3=theta*r2*r2;
            }
            else {
                hgt=sqrt(r1*r1-SQR(sep-r2));
                a2=hgt*(sep-r2);
                a3=0.0;
            }
            /* one disc much bigger-treat boundary as a straight line */
            a1=(PI-phi)*r1*r1;

            /* area of non-overlapped portion of small disc */
            a=a1+a2-a3;
            a1=PI*rs*rs;
            if (rs>rp) {
                return (a1+a-PI*rp*rp)/a1;
            }
            else {
                /* sun is small disc */
                return a/a1;
            }
        }
        /* eclipsing body lies within sun's disc-what fration of sun's disk is blocked */
        return (rs*rs-rp*rp)/(rs*rs);
    }
}
/* geometrical shadow model---------------------------------------------------*/
static double shadowgeometrical(gtime_t tutc, const double *rsun, const double *rsunssb, const double *rmoon, const double *rearth, const double *rss)
{
    const double R_E=6378137.0;
    const double R_S=696000000.0;
    const double R_M=1738000.0;
    double pc[3],cc[3],ps[3],sb[3],bc[3],sbp[3],lambda=1.0,rb,rc,ub[3];
    double sepp[3],rsbx,rs,rp,sep,psc[3],sbpc[3],rps;
    int i;

    /* lambda=1.0: no shadow
     * lambda=0.0: no sunlight
     * lambda=[0,1]: partial shadow
     */
    for (i=0;i<3;i++) {
        ps[i]=rmoon[i]-rsun[i];
        cc[i]=rearth[i]-rsunssb[i];
        pc[i]=rmoon[i];
        sb[i]=rss[i];
        bc[i]=rss[i]-rsun[i];
        sbp[i]=rss[i]-rmoon[i];
    }
    rb=norm(bc,3);
    rc=norm(cc,3);

    if (rb>rc) {
        /* unit vector of satellite wrt sun */
        for (i=0;i<3;i++) ub[i]=bc[i]/rb;
        cross3(sb,ub,sepp);

        /* projection of sb along bc */
        rsbx=dot(sb,ub,3);

        /* rs/rp are apparent (from satellite radii of sun and earth),
         * sep is apparent separation of their centers */
        rs=R_S/rb; rp=R_E/rsbx;
        sep=norm(sepp,3)/rsbx;
        lambda=getlambda(rs,rp,sep);
    }
    /* if no earth eclipse,then check moon */
    if (lambda<1.0) {
        return lambda;
    }
    else {
        for (i=0;i<3;i++) {
            psc[i]=pc[i]+cc[i];
            sbpc[i]=sb[i]-pc[i];
        }
        rps=norm(psc,3);
        if (rb<=rps) return lambda;

        /* unit vector of satellite wrt sun */
        for (i=0;i<3;i++) ub[i]=bc[i]/rb;

        /* projection of sb along bc */
        rsbx=dot(sbp,ub,3);

        /* rs/rp are apparent (from satellite radii of sun and earth),
         * sep is apparent separation of their centers */
        rs=R_S/rb; rp=R_M/rsbx;
        cross3(sbp,ub,sepp);
        sep=norm(sepp,3)/rsbx;
        lambda=getlambda(rs,rp,sep);
        return lambda;
    }
}
/* cylindrical shadow model---------------------------------------------------*/
static double shadowcylindrical(gtime_t tutc, const double *rsun, const double *rsunssb, const double *rmoon, const double *rearth, const double *rs)
{
    const double R_E=6378137.0;
    double es[3],ts[3],s,nu=0.0;

    es[0]=rsun[0]/norm(rsun,3);
    es[1]=rsun[1]/norm(rsun,3);
    es[2]=rsun[2]/norm(rsun,3);
    s=dot(rs,es,3);
    ts[0]=rs[0]-s*es[0];
    ts[1]=rs[1]-s*es[1];
    ts[2]=rs[2]-s*es[2];
    if (s>0.0||norm(ts,3)>R_E) nu=1.0;
    return nu;
}
/* shadow model---------------------------------------------------------------*/
static double shadow(int opt, gtime_t tutc, const double *rsun, const double *rsunssb, const double *rmoon, const double *rearth, const double *rs)
{
    if (norm(rsun   ,3)<=0.0) return 0.0;
    if (norm(rsunssb,3)<=0.0) return 0.0;
    if (norm(rmoon  ,3)<=0.0) return 0.0;
    if (norm(rearth ,3)<=0.0) return 0.0;

    switch (opt) {
        case SHADOW_CYLINDRICAL: return shadowcylindrical(tutc,rsun,rsunssb,rmoon,rearth,rs);
        case SHADOW_GEOMETRICAL: return shadowgeometrical(tutc,rsun,rsunssb,rmoon,rearth,rs);
        case SHADOW_CONICAL    : return shadowconical    (tutc,rsun,rsunssb,rmoon,rearth,rs);
    }
}
/* normalized Legendre polynomial values--------------------------------------
 * args:    int N       I  maximum degree
 *          int M       I  maximum order
 *          double fi   I  angle(rad)
 *          double *P   I  normalized associated legendre functions
 *          double *P1  I  1st-order derivatives of P
 *          double *P2  I  2st-order derivatives of P
 * return: none
 * ---------------------------------------------------------------------------*/
extern void legendre(int N, int M, double fi, double *P, double *P1, double *P2)
{
    double delta,fn,gnm,hnm,knm;
    int n,m,p=N+1,q=M+1;

    for (n=0;n<p;n++) for (m=0;m<q;m++) P[n*q+m]=0.0;

    for (P[0]=1.0,n=1;n<=N;n++) {
        delta=((1==n)?1.0:0.0);

        for (m=0;m<=n;m++) {
            if (m==n) {
                fn=sqrt((1.0+delta)*(2*n+1.0)/(2*n));
                P[m+n*q]=fn*cos(fi)*P[(m-1)+(n-1)*q];
            }
            else {
                gnm=sqrt((2*n+1.0)*(2*n-1.0)/(n+m)/(n-m));
                hnm=sqrt((2*n+1.0)*(n-m-1.0)*(n+m-1.0)/(2*n-3.0)/(n+m)/(n-m));
                if (m==n-1) {
                    P[m+n*q]=gnm*sin(fi)*P[m+(n-1)*q];

                }
                else {
                    P[m+n*q]=gnm*sin(fi)*P[m+(n-1)*q]-hnm*P[m+(n-2)*q];
                }
            }
        }
    }
    if (P1) {
        for (n=0;n<p;n++) for (m=0;m<q;m++) P1[n*q+m]=0.0;
        for(n=0;n<=N;n++) {
            for(m=0;m<=n;m++) {
                delta=((0==m)?1.0:0.0 );
                knm=sqrt((2.0-delta)*(n-m)*(n+m+1.0)/2);
                if(m==n) {
                    P1[m+n*q]=-m*tan(fi)*P[m+n*q];
                }
                else {
                    P1[m+n*q]=knm*P[(m+1)+n*q]-m*tan(fi)*P[m+n*q];
                }
            }
        }
    }
    if (P2) {
        for (n=0;n<p;n++) for (m=0;m<q;m++) P2[m+n*q]=0.0;
        for(n=0;n<=N;n++) {
            for(m=0;m<=n;m++) {
                P2[m+n*q]=(m*m/cos(fi)/cos(fi)-n*(n+1))*P[m+n*q]+tan(fi)*P1[m+n*q];
            }
        }
    }
}
/* initial gravity filed model------------------------------------------------*/
static void initgrvmmdl(force_model_t *fmdl, gravity_model_t *gm, const force_model_opt_t *opt)
{
    int i,j,N,tidesystem;
    char name[32];
    double *C,*S,RE,GM;
    static gravity_model_t *gms=NULL;

    fmdl->gms=&gms;
    if (gm->M&&gm->N) return;

    if (gms!=NULL) {
        gm->C=gms->C;
        gm->S=gms->S;
        gm->N=gms->N;
        gm->M=gms->M;
        gm->RE=gms->RE;
        gm->GM=gms->GM;
        gm->tidesystem=gms->tidesystem;
        strcpy(gm->name,gms->name);

        gm->solidtide=gms->solidtide;
        gm->oceantide=gms->oceantide;
        gm->poletide=gms->poletide;
        gm->anelasticearth=gms->anelasticearth;
        gm->fmdl=fmdl;
        fmdl->noneedfreegry=1;
        return;
    }
    if ((N=readgfc(opt->gfcfile,&C,&S,&RE,&GM,name,&tidesystem))<=0) return;

    gm->C=mat(opt->gN+1,opt->gM+1);
    gm->S=mat(opt->gN+1,opt->gM+1);
    gm->N=opt->gN;
    gm->M=opt->gM;
    gm->RE=RE;
    gm->GM=GM;
    gm->tidesystem=tidesystem;
    strcpy(gm->name,name);

    for (i=0;i<opt->gN+1;i++) {
        for (j=0;j<opt->gM+1;j++) {
            gm->C[i+j*(opt->gM+1)]=C[i+j*(N+1)];
            gm->S[i+j*(opt->gM+1)]=S[i+j*(N+1)];
        }
    }
    gm->solidtide=opt->solidtide;
    gm->oceantide=opt->oceantide;
    gm->poletide=opt->poletide;
    gm->anelasticearth=opt->anelasticearth;
    gm->fmdl=fmdl;
    fmdl->noneedfreegry=0;
    free(C); free(S);

    if (opt->usesamegravitymdl) {
        if (gms==NULL) gms=gm;
    }
}
/* initial atmospheric drag model---------------------------------------------*/
static void initatmdrag(force_model_t *fmdl, atmospheric_drag_t *atmdrag, const force_model_opt_t *opt)
{
    atmdrag->atmdensopt=opt->atmdensopt;
    atmdrag->area=opt->atmdrgparas[0];
    atmdrag->mass=opt->atmdrgparas[1];
    atmdrag->CD  =opt->atmdrgparas[2];
    atmdrag->fmdl=fmdl;

    if (fmdl->spw.n) return;

    static spw_t spws={0};
    fmdl->spws=&spws;

    if (opt->usesamespw&&spws.n) {
        fmdl->spw=spws;
        fmdl->noneedfreespw=1;
    }
    else {
        readspw(opt->spwfile,&fmdl->spw);
    }
    if (spws.n==0) {
        spws.n=fmdl->spw.n;
        spws.nmax=fmdl->spw.nmax;
        spws.data=fmdl->spw.data;
        fmdl->noneedfreespw=0;
    }
}
/* initial solar radiation pressure model-------------------------------------*/
static void initsolradp(force_model_t *fmdl, solrad_pressure_t *solrad, const force_model_opt_t *opt)
{
    solrad->area=opt->solradparas[0];
    solrad->mass=opt->solradparas[1];
    solrad->CR  =opt->solradparas[2];
    solrad->P0  =opt->solradparas[3];
    solrad->Au  =opt->solradparas[4];
    solrad->shmopt=opt->shmopt;
    solrad->solradmdl=opt->solradmdl;
    solrad->D0=opt->D0;
    solrad->Dc=opt->Dc;
    solrad->Ds=opt->Ds;
    solrad->B0=opt->B0;
    solrad->Bc=opt->Bc;
    solrad->Bs=opt->Bs;
    solrad->Y0=opt->Y0;
    solrad->Yc=opt->Yc;
    solrad->Ys=opt->Ys;
    solrad->Dc2=opt->Dc2;
    solrad->Ds2=opt->Ds2;
    solrad->Dc4=opt->Dc4;
    solrad->Ds4=opt->Ds4;
    solrad->fmdl=fmdl;
}
/* initial relativistic effects model-----------------------------------------*/
static void initrelatvt(force_model_t *fmdl, relatvty_mode_t *relavt, const force_model_opt_t *opt)
{
    relavt->fmdl=fmdl;
}
/* initial N-body perturbation model------------------------------------------*/
static void initnbpertn(force_model_t *fmdl, nbody_perturbation_t *nbpert, const force_model_opt_t *opt)
{
    /* Gravitational coefficients */
    const double GM_EARTH  =398600.4415E9;
    const double GM_SUN    =132712440041.279419E9;
    const double GM_MOON   =GM_EARTH/81.3005682214972154;
    const double GM_MERCURY=22031.868551E9;
    const double GM_VENUS  =324858.592000E9;
    const double GM_MARS   =42828.375816E9;
    const double GM_JUPITER=126712764.100000E9;
    const double GM_SATURN =37940584.841800E9;
    const double GM_URANUS =5794556.400000E9;
    const double GM_NEPTUNE=6836527.100580E9;
    const double GM_PLUTO  =975.500000E9;

    readjplde440coeffs(opt->jplde440file);
    nbpert->rr[GI_MERCURY][3]=GM_MERCURY;
    nbpert->rr[GI_VENUS  ][3]=GM_VENUS;
    nbpert->rr[GI_MARS   ][3]=GM_MARS;
    nbpert->rr[GI_JUPITER][3]=GM_JUPITER;
    nbpert->rr[GI_SATURN ][3]=GM_SATURN;
    nbpert->rr[GI_URANUS ][3]=GM_URANUS;
    nbpert->rr[GI_NEPTUNE][3]=GM_NEPTUNE;
    nbpert->rr[GI_PLUTO  ][3]=GM_PLUTO;
    nbpert->rr[GI_MOON   ][3]=GM_MOON;
    nbpert->rr[GI_SUN    ][3]=GM_SUN;
    nbpert->rr[GI_SUNSSB ][3]=GM_SUN;
    nbpert->rr[GI_EARTH  ][3]=GM_EARTH;
    nbpert->fmdl=fmdl;
}
/* initial ocean tide model---------------------------------------------------*/
static void initotdemdl(force_model_t *fmdl, oceantide_model_t *ot, const force_model_opt_t *opt)
{
    static oceantide_model_t otms={0};

    fmdl->otms=&otms;
    if (ot->n) return;

    if (opt->usesameotm) {
        if (otms.n) {
            *ot=otms;
            fmdl->noneedfreeotm=1;
            return;
        }
    }
    ot->mdldata=calloc(1024,sizeof(oceantide_model_coeffs_t));
    ot->nmax=1024;
    ot->maxl=opt->oL;
    ot->maxm=opt->oM;
    readotfile(opt->octfile,ot);
    fmdl->noneedfreeotm=0;

    if (otms.n==0) otms=*ot;
}
/* initial eop data-----------------------------------------------------------*/
static void initeopmdl(force_model_t *fmdl, const force_model_opt_t *opt)
{
    static erp_t erps={0};

    fmdl->erps=&erps;
    if (fmdl->erp.n) return;

    if (opt->usesameeop&&erps.n) {
        fmdl->erp=erps;
        fmdl->noneedfreeerp=1;
    }
    else {
        readeop(opt->eopfile,&fmdl->erp,opt->eopfiletype);
    }
    if (erps.n==0) {
        erps.n=fmdl->erp.n;
        erps.nmax=fmdl->erp.nmax;
        erps.data=fmdl->erp.data;
        fmdl->noneedfreeerp=0;
    }
}
/* free ocean tide model------------------------------------------------------*/
static void freeotdemdl(oceantide_model_t *ot)
{
    free(ot->mdldata);
}
/* free gravity filed model---------------------------------------------------*/
static void freegrvmmdl(gravity_model_t *gm)
{
    free(gm->C);
    free(gm->S);
}
/* initial force model--------------------------------------------------------*/
extern void forcemdlinit(force_model_t *fmdl, const force_model_opt_t *opt)
{
    initgrvmmdl(fmdl,&fmdl->gm,opt);
    initatmdrag(fmdl,&fmdl->ad,opt);
    initsolradp(fmdl,&fmdl->sp,opt);
    initnbpertn(fmdl,&fmdl->np,opt);
    initotdemdl(fmdl,&fmdl->ot,opt);
    initrelatvt(fmdl,&fmdl->rt,opt);
    initeopmdl(fmdl,opt);
    fmdl->opt=*opt;
}
/* free force model-----------------------------------------------------------*/
extern void forcemdlfree(force_model_t *fmdl)
{
    if (!fmdl->noneedfreegry) freegrvmmdl(&fmdl->gm);
    if (!fmdl->noneedfreeotm) freeotdemdl(&fmdl->ot);
    if (!fmdl->noneedfreeerp) free(fmdl->erp.data);
    if (!fmdl->noneedfreespw) free(fmdl->spw.data);
    if (fmdl->gms ) *fmdl->gms =NULL;
    if (fmdl->spws) memset(fmdl->spws,0,sizeof(*fmdl->spws));
    if (fmdl->otms) memset(fmdl->otms,0,sizeof(*fmdl->otms));
    if (fmdl->erps) memset(fmdl->erps,0,sizeof(*fmdl->erps));
    memset(fmdl,0,sizeof(*fmdl));
}
/* update earth rotation parameters------------------------------------------*/
extern void upateerpv(const erpd_t *erp, double *erpv)
{
    /* update earth rotation parameters */
    erpv[0]=erp->xp;
    erpv[1]=erp->yp;
    erpv[2]=erp->ut1_utc;
    erpv[3]=erp->lod;
    erpv[4]=erp->tai_utc;
}
/* compute doodson's fundamental arguments (beta)-----------------------------
 * and fundamental arguments for nutation (funt)
 * --------------------------------------------------------------------------*/
extern void doodsonargs(gtime_t tutc, const erpd_t *erp, double *beta, double *funt)
{
    const double mjd0=2400000.5;
    const double TURNAS=360.0*3600.0;
    const double mjd_j2000=51544.5;
    double erpv[6],mjd_utc,mjd_ut1,mjd_tt,gmst,t;

    /* update earth rotation parameters */
    upateerpv(erp,erpv);

    mjd_utc=time2mjd(tutc);
    mjd_ut1=time2mjdut1(tutc,erpv);
    mjd_tt=time2mjdtt(tutc,erpv);

    gmst=iauGmst06(mjd0,mjd_ut1,mjd0,mjd_tt);
    t=(mjd_tt-mjd_j2000)/36525.0;

    /* mean arguments of luni-solar motion:
     * l : mean anomaly of moon
     * l': mean anomaly of sun
     * F : mean argument of latitude
     * D : mean longitude elongation of moon from sun
     * Om: mean longitude of ascending node of moon
     */
    double l,lp,F,D,Om;
    l =fmod((485868.249036+1717915923.2178*t+31.8792*t*t+0.051635*t*t*t-0.00024470*t*t*t*t),TURNAS)*AS2R;
    lp=fmod((1287104.79305+129596581.04810*t-0.55320*t*t+0.000136*t*t*t-0.00001149*t*t*t*t),TURNAS)*AS2R;
    F =fmod((335779.526232+1739527262.8478*t-12.7512*t*t-0.001037*t*t*t+0.00000417*t*t*t*t),TURNAS)*AS2R;
    D =fmod((1072260.70369+1602961601.2090*t-6.37060*t*t+0.006593*t*t*t-0.00003169*t*t*t*t),TURNAS)*AS2R;
    Om=fmod((450160.398036-6962890.5431000*t+7.47220*t*t+0.007702*t*t*t-0.00005939*t*t*t*t),TURNAS)*AS2R;

    funt[0]=iauAnpm(l );
    funt[1]=iauAnpm(lp);
    funt[2]=iauAnpm(F );
    funt[3]=iauAnpm(D );
    funt[4]=iauAnpm(Om);

    double S=funt[2]+funt[4];
    beta[0]=gmst+PI-S;
    beta[1]=funt[2]+funt[4];
    beta[2]=S-funt[3];
    beta[3]=S-funt[0];
    beta[4]=-funt[4];
    beta[5]=S-funt[3]-funt[1];
}
/* corrections of solid earth tides--------------------------------------------*/
static void solidtidecorr(gtime_t tutc, const erpd_t *erp, const gravity_model_t *gm, const double *rs, double *C, double *S, int n, int m)
{
    /* for dC21 and dS21
     * the coefficients we choose are in-phase(ip) amplitudes and out-of-phase
     * amplitudes of the corrections for frequency dependence, and multipliers
     * of the Delaunay variables Refer to table 6.5a in IERS2010
     */
    const double coeff0[48][7]={
            /* l   l'  F   D   Om  Amp(R) Amp(I) */
            { 2,  0,  2,  0,  2,  -0.1,   0.0},
            { 0,  0,  2,  2,  2,  -0.1,   0.0},
            { 1,  0,  2,  0,  1,  -0.1,   0.0},
            { 1,  0,  2,  0,  2,  -0.7,   0.1},
            {-1,  0,  2,  2,  2,  -0.1,   0.0},
            { 0,  0,  2,  0,  1,  -1.3,   0.1},
            { 0,  0,  2,  0,  2,  -6.8,   0.6},
            { 0,  0,  0,  2,  0,   0.1,   0.0},
            { 1,  0,  2, -2,  2,   0.1,   0.0},
            {-1,  0,  2,  0,  1,   0.1,   0.0},
            {-1,  0,  2,  0,  2,   0.4,   0.0},
            { 1,  0,  0,  0,  0,   1.3,  -0.1},
            { 1,  0,  0,  0,  1,   0.3,   0.0},
            {-1,  0,  0,  2,  0,   0.3,   0.0},
            {-1,  0,  0,  2,  1,   0.1,   0.0},
            { 0,  1,  2, -2,  2,  -1.9,   0.1},
            { 0,  0,  2, -2,  1,   0.5,   0.0},
            { 0,  0,  2, -2,  2, -43.4,   2.9},
            { 0, -1,  2, -2,  2,   0.6,   0.0},
            { 0,  1,  0,  0,  0,   1.6,  -0.1},
            {-2,  0,  2,  0,  1,   0.1,   0.0},
            { 0,  0,  0,  0, -2,   0.1,   0.0},
            { 0,  0,  0,  0, -1,  -8.8,   0.5},
            { 0,  0,  0,  0,  0, 470.9, -30.2},
            { 0,  0,  0,  0,  1,  68.1,  -4.6},
            { 0,  0,  0,  0,  2,  -1.6,   0.1},
            {-1,  0,  0,  1,  0,   0.1,   0.0},
            { 0, -1,  0,  0, -1,  -0.1,   0.0},
            { 0, -1,  0,  0,  0,  -20.6, -0.3},
            { 0,  1, -2,  2, -2,   0.3,   0.0},
            { 0, -1,  0,  0,  1,  -0.3,   0.0},
            {-2,  0,  0,  2,  0,  -0.2,   0.0},
            {-2,  0,  0,  2,  1,  -0.1,   0.0},
            { 0,  0, -2,  2, -2,  -5.0,   0.3},
            { 0,  0, -2,  2, -1,   0.2,   0.0},
            { 0, -1, -2,  2, -2,  -0.2,   0.0},
            { 1,  0,  0, -2,  0,  -0.5,   0.0},
            { 1,  0,  0, -2,  1,  -0.1,   0.0},
            {-1,  0,  0,  0, -1,   0.1,   0.0},
            {-1,  0,  0,  0,  0,  -2.1,   0.1},
            {-1,  0,  0,  0,  1,  -0.4,   0.0},
            { 0,  0,  0, -2,  0,  -0.2,   0.0},
            {-2,  0,  0,  0,  0,  -0.1,   0.0},
            { 0,  0, -2,  0, -2,  -0.6,   0.0},
            { 0,  0, -2,  0, -1,  -0.4,   0.0},
            { 0,  0, -2,  0,  0,  -0.1,   0.0},
            {-1,  0, -2,  0, -2,  -0.1,   0.0},
            {-1,  0, -2,  0, -1,  -0.1,   0.0}
    };
    /* for dC20
     * the nominal value k20 for the zonal tides is taken as 0.30190
	 * refer to table 6.5b in IERS2010
     */
    const double coeff1[21][7]={
            /* l   l'  F   D   Om  Amp(R)  Amp(I) */
            { 0,  0,  0,  0,  1,  16.6,  -6.7},
            { 0,  0,  0,  0,  2,  -0.1,   0.1},
            { 0, -1,  0,  0,  0,  -1.2,   0.8},
            { 0,  0, -2,  2, -2,  -5.5,   4.3},
            { 0,  0, -2,  2, -1,   0.1,  -0.1},
            { 0, -1, -2,  2, -2,  -0.3,   0.2},
            { 1,  0,  0, -2,  0,  -0.3,   0.7},
            {-1,  0,  0,  0, -1,   0.1,  -0.2},
            {-1,  0,  0,  0,  0,  -1.2,   3.7},
            {-1,  0,  0,  0,  1,   0.1,  -0.2},
            { 1,  0, -2,  0, -2,   0.1,  -0.2},
            { 0,  0,  0, -2,  0,   0.0,   0.6},
            {-2,  0,  0,  0,  0,   0.0,   0.3},
            { 0,  0, -2,  0, -2,   0.6,   6.3},
            { 0,  0, -2,  0, -1,   0.2,   2.6},
            { 0,  0, -2,  0,  0,   0.0,   0.2},
            { 1,  0, -2, -2, -2,   0.1,   0.2},
            {-1,  0, -2,  0, -2,   0.4,   1.1},
            {-1,  0, -2,  0, -1,   0.2,   0.5},
            { 0,  0, -2, -2, -2,   0.1,   0.2},
            {-2,  0, -2,  0, -2,   0.1,   0.1}
    };
    /* for dC22 and dS22
     * refer to table 6.5c in IERS2010
     */
    const double coeff2[2][6]={
            /* l  l' F  D  Om  Amp */
            { 1, 0, 2, 0, 2, -0.3},
            { 0, 0, 2, 0, 2, -1.2}
    };
    const double mjd0=2400000.5;
    const double DAS2R=4.848136811095359935899141E-6;
    const double TURNAS=360.0*3600.0;
    double erpv[5]={0.0},lM,lS,phiM,phiS,rM,rS,pa[2],*lgM,*lgS,a,b,c,d,mjd_tt,mjd_utc,mjd_ut1,beta[6],funt[6];
    force_model_t *fmdl=gm->fmdl;
    int i;

    /* update earth rotation parameters */
    upateerpv(erp,erpv);

    mjd_utc=time2mjd(tutc);
    mjd_ut1=time2mjdut1(tutc,erpv);
    mjd_tt=time2mjdtt(tutc,erpv);

    polarang(fmdl->np.rr[GI_MOON],pa); lM=pa[0]; phiM=pa[1];
    polarang(fmdl->np.rr[GI_SUN ],pa); lS=pa[0]; phiS=pa[1];
    rM=norm(fmdl->np.rr[GI_MOON],3);
    rS=norm(fmdl->np.rr[GI_SUN ],3);

    /* mean arguments of luni-solar motion */
    doodsonargs(tutc,erp,beta,funt);

    a=fmdl->np.rr[GI_MOON][3]/gm->GM*pow(gm->RE/rM,3.0);
    b=fmdl->np.rr[GI_SUN ][3]/gm->GM*pow(gm->RE/rS,3.0);
    c=fmdl->np.rr[GI_MOON][3]/gm->GM*pow(gm->RE/rM,4.0);
    d=fmdl->np.rr[GI_SUN ][3]/gm->GM*pow(gm->RE/rS,4.0);

    if (gm->anelasticearth) {

        lgM=mat(3,3);
        lgS=mat(3,3);
        legendre(2,2,phiM,lgM,NULL,NULL);
        legendre(2,2,phiS,lgS,NULL,NULL);
        double dCnm[5][3]={0},dSnm[5][3]={0},dC20,dC21,dS21,theta_f,theta_g,dC22,dS22;
        const double k2c[3]={ 0.30190, 0.29830, 0.30102};
        const double k4c[3]={-0.00089,-0.00080,-0.00057};
        const double k2s[3]={ 0.00000, 0.00144, 0.00130};
        const double k4s[3]={ 0.00000,-0.00080,-0.00057};

        for (i=0;i<=2;i++) {
            dCnm[2][i]=k2c[i]/5.0*(a*lgM[2*3+i]*cos(i*lM)+b*lgS[2*3+i]*cos(i*lS))-k2s[i]/5.0*(a*lgM[2*3+i]*sin(i*lM)+b*lgS[2*3+i]*sin(i*lS));
            dCnm[4][i]=k4c[i]/5.0*(a*lgM[2*3+i]*cos(i*lM)+b*lgS[2*3+i]*cos(i*lS));
        }
        for (i=1;i<=2;i++) {
            dSnm[2][i]=k2s[i]/5.0*(a*lgM[2*3+i]*cos(i*lM)+b*lgS[2*3+i]*cos(i*lS))+k2c[i]/5.0*(a*lgM[2*3+i]*sin(i*lM)+b*lgS[2*3+i]*sin(i*lS));
            dSnm[4][i]=k4s[i]/5.0*(a*lgM[2*3+i]*sin(i*lM)+b*lgS[2*3+i]*sin(i*lS));
        }
        dC20=0.0;
        for (i=0;i<=20;i++) {
            theta_f=-dot(coeff1[i],funt,5);
            dC20+=1E-12*(coeff1[i][5]*cos(theta_f)-coeff1[i][6]*sin(theta_f));
        }
        dCnm[2][0]+=dC20;
        theta_g=iauGmst06(mjd0,mjd_ut1,mjd0,mjd_tt);
        dC21=0.0;
        dS21=0.0;
        for (i=0;i<=47;i++) {
            theta_f=(theta_g+PI)-dot(coeff0[i],funt,5);
            dC21+=1E-12*(coeff0[i][5]*sin(theta_f)+coeff0[i][6]*cos(theta_f));
            dS21+=1E-12*(coeff0[i][5]*cos(theta_f)-coeff0[i][6]*sin(theta_f));
        }
        dCnm[2][1]+=dC21;
        dSnm[2][1]+=dS21;
        dC22=0.0;
        dS22=0.0;
        for (i=0;i<=1;i++) {
            theta_f=2.0*(theta_g+PI)-dot(coeff2[i],funt,5);
            dC22+=1E-12*coeff2[i][5]*cos(theta_f);
            dS22-=1E-12*coeff2[i][5]*sin(theta_f);
        }
        dCnm[2][2]+=dC22;
        dSnm[2][2]+=dS22;

        /* treatment of the permanent tide (anelastic Earth) */
        dC20=4.4228E-8*(-0.31460)*0.30190;

        /* 4.173E-9 is added to C20 to convert to tide-free system */
        if (gm->tidesystem!=GRAVITY_MODEL_TIDE_FREE) {
            dCnm[2][0]+=4.173E-9-dC20;
        }
        /* update corrections */
        for (i=0;i<=2;i++) C[2*m+i]+=dCnm[2][i];
        for (i=1;i<=2;i++) S[2*m+i]+=dSnm[2][i];
        for (i=0;i<=2;i++) C[4*m+i]+=dCnm[4][i];
        for (i=1;i<=2;i++) S[4*m+i]+=dSnm[4][i];
        free(lgS); free(lgM);
    }
    else {
        lgM=mat(4,4);
        lgS=mat(4,4);
        legendre(3,3,phiM,lgM,NULL,NULL);
        legendre(3,3,phiS,lgS,NULL,NULL);

        double dCnm[5][5]={0},dSnm[5][5]={0},theta_g,theta_f,dC21,dS21,dC22,dS22,dC20;
        const double k2c[3]={0.29525,0.29470,0.29801};
        const double k2s[3]={0.00000,0.29470,0.29801};
        const double k3c[4]={0.093,0.093,0.093,0.094};
        const double k3s[4]={0.000,0.093,0.093,0.094};
        const double k4c[3]={-0.00087,-0.00079,-0.00057};
        const double k4s[3]={ 0.00000,-0.00079,-0.00057};

        for (i=0;i<=2;i++) {
            dCnm[2][i]=k2c[i]/5.0*(a*lgM[2*4+i]*cos(i*lM)+b*lgS[2*4+i]*cos(i*lS));
            dSnm[2][i]=k2s[i]/5.0*(a*lgM[2*4+i]*sin(i*lM)+b*lgS[2*4+i]*sin(i*lS));
        }
        for (i=0;i<=3;i++) {
            dCnm[3][i]=k3c[i]/7.0*(c*lgM[3*4+i]*cos(i*lM)+d*lgS[3*4+i]*cos(i*lS));
            dSnm[3][i]=k3s[i]/7.0*(c*lgM[3*4+i]*sin(i*lM)+d*lgS[3*4+i]*sin(i*lS));
        }
        for (i=0;i<=2;i++) {
            dCnm[4][i]=k4c[i]/5.0*(a*lgM[2*4+i]*cos(i*lM)+b*lgS[2*4+i]*cos(i*lS));
            dSnm[4][i]=k4s[i]/5.0*(a*lgM[2*4+i]*sin(i*lM)+b*lgS[2*4+i]*sin(i*lS));
        }
        theta_g=iauGmst06(mjd0,mjd_ut1,mjd0,mjd_tt);
        dC21=0.0;
        dS21=0.0;
        for (i=0;i<=47;i++) {
            theta_f=(theta_g+PI)-dot(coeff0[i],funt,5);
            dC21+=1E-12*coeff0[i][5]*sin(theta_f);
            dS21+=1E-12*coeff0[i][5]*cos(theta_f);
        }
        dCnm[2][1]+=dC21;
        dSnm[2][1]+=dS21;
        dC22=0.0;
        dS22=0.0;
        for (i=0;i<=1;i++) {
            theta_f=2.0*(theta_g+PI)-dot(coeff2[i],funt,5);
            dC22+=1E-12*coeff2[i][5]*cos(theta_f);
            dS22-=1E-12*coeff2[i][5]*sin(theta_f);
        }
        dCnm[2][2]+=dC22;
        dSnm[2][2]+=dS22;

        /* treatment of the permanent tide (anelastic Earth) */
        dC20=4.4228E-8*(-0.31460)*0.29525;

        /* 4.173E-9 is added to C20 to convert to tide-free system */
        if (gm->tidesystem!=GRAVITY_MODEL_TIDE_FREE) {
            dCnm[2][0]+=4.173E-9-dC20;
        }
        /* update corrections */
        for (i=0;i<=2;i++) C[2*m+i]+=dCnm[2][i];
        for (i=1;i<=2;i++) S[2*m+i]+=dSnm[2][i];
        for (i=0;i<=3;i++) C[3*m+i]+=dCnm[3][i];
        for (i=1;i<=3;i++) S[3*m+i]+=dSnm[3][i];
        for (i=0;i<=2;i++) C[4*m+i]+=dCnm[4][i];
        for (i=1;i<=2;i++) S[4*m+i]+=dSnm[4][i];
        free(lgS); free(lgM);
    }
}
/* corrections of ocean tides using ocean tide model--------------------------*/
static void oceantidecorr_otm(gtime_t tutc, const erpd_t *erp, const gravity_model_t *gm, const double *rs, double *C, double *S, int n, int m)
{
    force_model_t *fmdl=gm->fmdl;
    oceantide_model_t *otm=&fmdl->ot;
    double beta[6],funt[6],theta;
    int i;

    if (otm->n<=0) return;

    /* mean arguments of luni-solar motion */
    doodsonargs(tutc,erp,beta,funt);

    /* correction to normalized earth potential coefficients */
    for (i=0;i<otm->n;i++) {
        theta=dot(otm->mdldata[i].dn,beta,6);
        C[otm->mdldata[i].l*m+otm->mdldata[i].m]+=(otm->mdldata[i].dCp+otm->mdldata[i].dCm)*cos(theta)+(otm->mdldata[i].dSp+otm->mdldata[i].dSm)*sin(theta);
        S[otm->mdldata[i].l*m+otm->mdldata[i].m]+=(otm->mdldata[i].dSp-otm->mdldata[i].dSm)*cos(theta)+(otm->mdldata[i].dCp-otm->mdldata[i].dCm)*sin(theta);
    }
}
/* corrections of ocean tides on default option-------------------------------*/
static void oceantidecorr_def(gtime_t tutc, const erpd_t *erp, const gravity_model_t *gm, const double *rs, double *C, double *S, int n, int m)
{
    force_model_t *fmdl=gm->fmdl;
    const double M_EARTH=5.9722E24;
    const double DENSITY_SW=1025.0;
    double *lgM,*lgS,a,b,c,d,e,f,h,k,p,q,lM,lS,phiM,phiS,rM,rS,pa[2];
    int i,j;

    if (fmdl->opt.oceantide==OCEANTIDECORR_OTMODEL) {
        return oceantidecorr_otm(tutc,erp,gm,rs,C,S,n,m);
    }
    polarang(fmdl->np.rr[GI_MOON],pa); lM=pa[0]; phiM=pa[1];
    polarang(fmdl->np.rr[GI_SUN ],pa); lS=pa[0]; phiS=pa[1];
    rM=norm(fmdl->np.rr[GI_MOON],3);
    rS=norm(fmdl->np.rr[GI_SUN ],3);

    lgM=mat(7,7);
    lgS=mat(7,7);
    legendre(6,6,phiM,lgM,NULL,NULL);
    legendre(6,6,phiS,lgS,NULL,NULL);
    double dCnm[7][7]={0},dSnm[7][7]={0};
    const double kc[7]={0.0000,0.0000, 0.3075, 0.1950, 0.1320, 0.1032, 0.0892};
    const double ks[7]={0.0000,0.0000,-0.3075,-0.1950,-0.1320,-0.1032,-0.0892};

    for (i=2;i<=6;i++) {
        for (j=0;j<=i;j++) {
            c=2*i+1;
            a=fmdl->np.rr[GI_MOON][3]/gm->GM*pow(gm->RE/rM,i+1);
            b=fmdl->np.rr[GI_SUN ][3]/gm->GM*pow(gm->RE/rS,i+1);
            dCnm[i][j]=4.0*PI*pow(gm->RE,2.0)*DENSITY_SW/M_EARTH*(1.0-kc[i])/c*(a*lgM[i*7+j]*cos(j*lM)+b*lgS[i*7+j]*cos(j*lS));
        }
    }
    for (i=2;i<=6;i++) {
        for (j=0;j<=i;j++) {
            c=2*i+1;
            a=fmdl->np.rr[GI_MOON][3]/gm->GM*pow(gm->RE/rM,i+1);
            b=fmdl->np.rr[GI_SUN ][3]/gm->GM*pow(gm->RE/rS,i+1);
            dSnm[i][j]=ks[i]/c*(a*lgM[i*7+j]*sin(j*lM)+b*lgS[i*7+j]*sin(j*lS));
        }
    }
    for (i=2;i<=6;i++) {
        for (j=0;j<=i;j++) C[i*m+j]+=dCnm[i][j];
        for (j=0;j<=i;j++) S[i*m+j]+=dSnm[i][j];
    }
    free(lgM); free(lgS);
}
/* corrections of ocean tides ------------------------------------------------*/
static void oceantidecorr(int opt, gtime_t tutc, const erpd_t *erp, const gravity_model_t *gm, const double *rs, double *C, double *S, int n, int m)
{
    switch (opt) {
        case OCEANTIDECORR_DEFAULT: return oceantidecorr_def(tutc,erp,gm,rs,C,S,n,m);
        case OCEANTIDECORR_OTMODEL: return oceantidecorr_otm(tutc,erp,gm,rs,C,S,n,m);
    }
}
/* pole tide corrections------------------------------------------------------*/
static void poletidecorr(gtime_t tutc, const erpd_t *erp, const gravity_model_t *gm, const double *rs, double *C, double *S, int n, int m)
{
    const double mjd_j2000=51544.5;
    double mjd_utc;

    mjd_utc=time2mjd(tutc);

    double ly1=(mjd_utc-mjd_j2000)/365.25;
    double ly2=ly1*ly1;
    double ly3=ly2*ly1;

    /* coefficients of the IERS (2010) mean pole model(IERS2010-table7.7) */
    /* until 2010.0, mas/year */
    const double xp1[4]={ 55.974,1.8243, 0.18413, 0.007024};
    const double yp1[4]={346.346,1.7896,-0.10729,-0.000908};

    /* after 2010.0, mas/year */
    const double xp2[2]={ 23.513, 7.6141};
    const double yp2[2]={358.891,-0.6287};

    /* mean pole, unit: arcsec */
    double xpm=0.0,ypm=0.0;
    if (mjd_utc<55197.0) {
        xpm=(xp1[0]+xp1[1]*ly1+xp1[2]*ly2+xp1[3]*ly3)*1E-3;
        ypm=(yp1[0]+yp1[1]*ly1+yp1[2]*ly2+yp1[3]*ly3)*1E-3;
    }
    else {
        xpm=(xp2[0]+xp2[1]*ly1)*1E-3;
        ypm=(yp2[0]+yp2[1]*ly1)*1E-3;
    }
    /* real pole, unit: arcsec */
    double xp=erp->xp*R2AR;
    double yp=erp->yp*R2AR;

    /* difference of real and mean pole, unit: arcsec */
    double m1=xp-xpm,m2=-(yp-ypm);

    /* solid earth pole tide */
    C[2*m+1]+=-1.333E-9*(m1+0.0115*m2);
    S[2*m+1]+=-1.333E-9*(m2-0.0115*m1);

    /* ocean pole tide */
    C[2*m+1]+=2.1778E-10*(m1-0.01724*m2);
    S[2*m+1]=-1.7232E-10*(m2-0.03365*m1);
}
/* earth rotation corrections-------------------------------------------------*/
static void rotcorr(gtime_t tutc, const erpd_t *erp, const gravity_model_t *gm, const double *rs, double *C, double *S, int n, int m)
{
    const double mjd_j2000=51544.5;
    double mjd_utc,ep[6];

    mjd_utc=time2mjd(tutc);

    double ly1=(mjd_utc-mjd_j2000)/365.25;
    double ly2=ly1*ly1;
    double ly3=ly2*ly1;

    /* coefficients of the IERS (2010) mean pole model(IERS2010-table7.7) */
    /* until 2010.0, mas/year */
    const double xp1[4]={ 55.974,1.8243, 0.18413, 0.007024};
    const double yp1[4]={346.346,1.7896,-0.10729,-0.000908};

    /* after 2010.0, mas/year */
    const double xp2[2]={ 23.513, 7.6141};
    const double yp2[2]={358.891,-0.6287};

    /* low-degree coefficients of conventional geopotential model */
    /* C20, C30 and C40 at 2000.0 */
    const double value[3]={-0.48416531E-3, 0.9571612E-6, 0.5399659E-6};
    const double rate[3]={11.6E-12,4.9E-12,4.7E-12};

    C[2*m+0]=value[0]+ly1*rate[0];
    C[3*m+0]=value[1]+ly1*rate[1];
    C[4*m+0]=value[2]+ly1*rate[2];

    /* mean pole, unit: arcsec */
    double xpm=0.0,ypm=0.0;
    if (mjd_utc<55197.0) {
        xpm=(xp1[0]+xp1[1]*ly1+xp1[2]*ly2+xp1[3]*ly3)*1E-3;
        ypm=(yp1[0]+yp1[1]*ly1+yp1[2]*ly2+yp1[3]*ly3)*1E-3;
    }
    else {
        xpm=(xp2[0]+xp2[1]*ly1)*1E-3;
        ypm=(yp2[0]+yp2[1]*ly1)*1E-3;
    }
    /* arcsec convert to rad */
    xpm=xpm*AS2R;
    ypm=ypm*AS2R;

    /* use the gravitational potential coefficients to solve for a satellite orbit,
     * it is necessary to rotate fromthe Earth-fixed frame, where the coefficients are pertinent,
     * to an inertial frame, where the satellite motion is computed
     *
     * C21=+sqrt(3)*xpm*C20-xpm*C22+ypm*S22
     * S21=-sqrt(3)*ypm*C20-ypm*C22-xpm*S22
     */
    double C20=C[2*m+0];
    double C22=C[2*m+2];
    double S22=S[2*m+2];
    C[2*m+1]= sqrt(3.0)*xpm*C20-xpm*C22+ypm*S22;
    S[2*m+1]=-sqrt(3.0)*ypm*C20-ypm*C22-xpm*S22;
}
/* computes the acceleration due to earrh gravity filed------------------------
 * args   : gtime_t tutc         I  time in utc
 *          erpd_t *erp          I  earth rotation parameter data
 *          gravity_model_t *gm  I  earrh gravity filed model
 *          double *rs           I  satellite position (eci/m)
 *          double *fa           O  acceleration due to earrh gravity filed (eci,m/s^2)
 *          double *dadx         O  partial differential of acceleration wrt to parameters
 *          int uddadxmethod     I  update method for partial differential of acceleration wrt to parameters
 * return : none
 *----------------------------------------------------------------------------*/
extern void gravityforce(gtime_t tutc, const erpd_t *erp, const gravity_model_t *gm, const double *rs, double *fa, double *dadx, int uddadxmethod)
{
    double q1=0.0,q2=0.0,q3=0.0,b1,b2,b3,r2xy,at[3],G[3][3]={0},b[3][3]={0};
    double U[9],rr[3],d,lat,lon,dUdr=0.0,dUdlat=0.0,dUdlon=0.0,erpv[5],*P0,*P1,*P2,*C,*S,a;
    double dbdrho[3][3]={0},dbdlat[3][3]={0},dbdlon[3][3]={0},dfdrll[3][3]={0};
    int i,j,k,n=gm->N+1,m=gm->M+1;

    for (i=0;i<3;i++) fa[i]=0.0;

    if (gm->N<=0||gm->M<=0) return;

    C=zeros(n,m); S=zeros(n,m);
    P0=zeros(n,m); P1=zeros(n,m); P2=zeros(n,m);
    matcpy(C,gm->C,n,m);
    matcpy(S,gm->S,n,m);

    /* earth rotation corrections */
    if (gm->rotcorr) rotcorr(tutc,erp,gm,rs,C,S,n,m);

    /* solid tides corrections */
    if (gm->solidtide) solidtidecorr(tutc,erp,gm,rs,C,S,n,m);

    /* ocean tides corrections */
    if (gm->oceantide) oceantidecorr(gm->oceantide,tutc,erp,gm,rs,C,S,n,m);

    /* pole tides corrections */
    if (gm->poletide) poletidecorr(tutc,erp,gm,rs,C,S,n,m);

    /* update earth rotation parameters */
    upateerpv(erp,erpv);

    /* satellite position in ECEF(m) */
    ecsf2ecef(tutc,erpv,U,NULL,NULL);
    matmul("NN",3,1,3,1.0,U,rs,0.0,rr);
    d=norm(rr,3);

    lon=atan2(rr[1],rr[0]);
    lat=asin(rr[2]/d);

    legendre(gm->N,gm->M,lat,P0,P1,P2);

    /* computes acceleration due to earth gravity filed */
    for (i=0;i<=gm->N;i++) {
        b1=-gm->GM/SQR(d)*pow(gm->RE/d,i)*(i+1);
        b2= gm->GM/d*pow(gm->RE/d,i);
        b3= gm->GM/d*pow(gm->RE/d,i);

        for (j=0;j<=gm->M;j++) {
            q1+=  P0[i*m+j]*(C[i*m+j]*cos(j*lon)+S[i*m+j]*sin(j*lon));
            q2+=  P1[i*m+j]*(C[i*m+j]*cos(j*lon)+S[i*m+j]*sin(j*lon));
            q3+=j*P0[i*m+j]*(S[i*m+j]*cos(j*lon)-C[i*m+j]*sin(j*lon));
        }
        dUdr  =dUdr  +q1*b1;
        dUdlat=dUdlat+q2*b2;
        dUdlon=dUdlon+q3*b3;
        q1=q2=q3=0.0;
    }
    r2xy=SQR(rr[0])+SQR(rr[1]);
    at[0]=(1.0/d*dUdr-rr[2]/(SQR(d)*sqrt(r2xy))*dUdlat)*rr[0]-(1/r2xy*dUdlon)*rr[1];
    at[1]=(1.0/d*dUdr-rr[2]/(SQR(d)*sqrt(r2xy))*dUdlat)*rr[1]+(1/r2xy*dUdlon)*rr[0];
    at[2]= 1.0/d*dUdr*rr[2]+sqrt(r2xy)/SQR(d)*dUdlat;

    /* satellite acceleration in ECI(m/s^2) */
    matmul("TN",3,1,3,1.0,U,at,0.0,fa);

    if (dadx) {
        if (uddadxmethod==ACCLGRAD_ANALYSIS) {
            b1=gm->GM/d;
            b2=b1/d;
            b3=b2/d;
            for (i=0;i<=gm->N;i++) {
                a=pow(gm->RE/d,i);

                for (j=0;j<=i&&j<gm->M;j++) {
                    G[0][0]+= b3*(i+1)*(i+2)*a*P0[i*m+j]*( C[i*m+j]*cos(j*lon)+S[i*m+j]*sin(j*lon));
                    G[0][1]+=-b2*(i+1)*a*      P1[i*m+j]*( C[i*m+j]*cos(j*lon)+S[i*m+j]*sin(j*lon));
                    G[0][2]+=-b2*(i+1)*j*a*    P0[i*m+j]*(-C[i*m+j]*sin(j*lon)+S[i*m+j]*cos(j*lon));
                    G[1][1]+= b1*a*            P2[i*m+j]*( C[i*m+j]*cos(j*lon)+S[i*m+j]*sin(j*lon));
                    G[1][2]+= b1*j*a*          P1[i*m+j]*(-C[i*m+j]*sin(j*lon)+S[i*m+j]*cos(j*lon));
                    G[2][2]+=-b1*j*j*a*        P0[i*m+j]*( C[i*m+j]*cos(j*lon)+S[i*m+j]*sin(j*lon));
                }
            }
            G[1][0]=G[0][1];
            G[2][0]=G[0][2];
            G[2][1]=G[1][2];

            /* partials of (rho,lat,lon) in ITRS to (x,y,z) in ITRS */
            b[0][0]= cos(lat)*cos(lon);
            b[0][1]= cos(lat)*sin(lon);
            b[0][2]= sin(lat);
            b[1][0]=-sin(lat)*cos(lon)/d;
            b[1][1]=-sin(lat)*sin(lon)/d;
            b[1][2]= cos(lat)/d;
            b[2][0]=-sin(lon)/(d*cos(lat));
            b[2][1]= cos(lon)/(d*cos(lat));

            /* partials of b to (rho, lat, lon) in ITRS */
            dbdrho[1][0]= sin(lat)*cos(lon)/(d*d);
            dbdrho[1][1]= sin(lat)*sin(lon)/(d*d);
            dbdrho[1][2]=-cos(lat)/(d*d);
            dbdrho[2][0]= sin(lon)/(d*d*cos(lat));
            dbdrho[2][1]=-cos(lon)/(d*d*cos(lat));

            dbdlat[0][0]=-sin(lat)*cos(lon);
            dbdlat[0][1]=-sin(lat)*sin(lon);
            dbdlat[0][2]= cos(lat);
            dbdlat[1][0]=-cos(lat)*cos(lon)/d;
            dbdlat[1][1]=-cos(lat)*sin(lon)/d;
            dbdlat[1][2]=-sin(lat)/d;
            dbdlat[2][0]=-sin(lat)*sin(lon)/(d*cos(lat)*cos(lat));
            dbdlat[2][1]= sin(lat)*cos(lon)/(d*cos(lat)*cos(lat));

            dbdlon[0][0]=-cos(lat)*sin(lon);
            dbdlon[0][1]= cos(lat)*cos(lon);
            dbdlon[1][0]= sin(lat)*sin(lon)/d;
            dbdlon[1][1]=-sin(lat)*cos(lon)/d;
            dbdlon[2][0]=-cos(lon)/(d*cos(lat));
            dbdlon[2][1]=-sin(lon)/(d*cos(lat));
            at[0]=dUdr;
            at[1]=dUdlat;
            at[2]=dUdlon;

            for (i=0;i<3;i++) {
                for (k=0;k<3;k++) {
                    dfdrll[i][0]+=G[k][0]*b[k][i]+at[k]*dbdrho[k][i];
                    dfdrll[i][1]+=G[k][1]*b[k][i]+at[k]*dbdlat[k][i];
                    dfdrll[i][2]+=G[k][2]*b[k][i]+at[k]*dbdlon[k][i];
                }
            }
            double bt[9],dfdrllt[9],T[9],W[9];
            double dadp[9];
            for (i=0;i<3;i++) {
                for (j=0;j<3;j++) bt[i+j*3]=b[i][j];
                for (j=0;j<3;j++) dfdrllt[i+j*3]=dfdrll[i][j];
            }
            matmul("TN",3,3,3,1.0,U,dfdrllt,0.0,T);
            matmul("NN",3,3,3,1.0,T,bt,0.0,W);
            matmul("NN",3,3,3,1.0,W,U,0.0,dadp);

            for (i=0;i<3;i++) {
                for (j=GIP;j<GIP+3;j++) dadx[i+j*3]=dadp[i+(j-GIP)*3];
            }
        }
        else if (uddadxmethod==ACCLGRAD_NUMDIFF_SEP) {
            double dr=0.001;
            double fa0[3],fa1[3];
            double r0[6],r1[6];

            /* partial differential for position */
            for (i=0;i<3;i++) {
                matcpy(r0,rs,1,6);
                matcpy(r1,rs,1,6);
                r0[GIP+i]-=dr;
                r1[GIP+i]+=dr;

                gravityforce(tutc,erp,gm,r0,fa0,NULL,0);
                gravityforce(tutc,erp,gm,r1,fa1,NULL,0);
                for (j=0;j<3;j++) {
                    dadx[j+(GIP+i)*3]=(fa1[j]-fa0[j])/(2.0*dr);
                }
            }
        }
    }
    free(C); free(S); free(P0); free(P1); free(P2);
}
/* solar radiation pressure default model-------------------------------------*/
static void solradmdl_deft(gtime_t tutc, const erpd_t *erp, const solrad_pressure_t *sp, const double *rs, const char *blocktype, double *fa, double *dadx, int uddadxmethod)
{
    double nu,bc[3],r,fact;
    force_model_t *fmdl=sp->fmdl;
    int i,j;

    for (i=0;i<3;i++) fa[i]=0.0;
    if (norm(rs,3)<=0.0) return;
    if (norm(fmdl->np.rr[GI_SUN],3)<=0.0) return;

    /* shadow factor */
    nu=shadow(sp->shmopt,tutc,fmdl->np.rr[GI_SUN],fmdl->np.rr[GI_SUNSSB],fmdl->np.rr[GI_MOON],fmdl->np.rr[GI_EARTH],rs);
    bc[0]=rs[0]-fmdl->np.rr[GI_SUN][0];
    bc[1]=rs[1]-fmdl->np.rr[GI_SUN][1];
    bc[2]=rs[2]-fmdl->np.rr[GI_SUN][2];
    r=norm(bc,3);

    /* solar radiation pressure force */
    fact=nu*sp->CR*(sp->area/sp->mass)*sp->P0*(sp->Au*sp->Au);
    fa[0]=fact*bc[0]/(r*r*r);
    fa[1]=fact*bc[1]/(r*r*r);
    fa[2]=fact*bc[2]/(r*r*r);

    if (dadx) if (uddadxmethod==ACCLGRAD_ANALYSIS) {
        double r5=pow(r,5);
        double r3=pow(r,3);

        for (i=0;i<3;i++) {
            for (j=0;j<3;j++) {
                if (i==j) dadx[i+(GIP+i)*3]=fact*(1.0/r3-6.0*SQR(bc[i]));
                else      dadx[j+(GIP+i)*3]=fact*(-6.0*bc[i]*bc[j]/r5);
            }
        }
    }
}
/* set srp parameters--------------------------------------------------------*/
static void fmdlsetsrp(force_model_t *fmdl, int ip, double val)
{
    switch (ip) {
        case GIS_D0 : fmdl->sp.D0 =val; break;
        case GIS_DC : fmdl->sp.Dc =val; break;
        case GIS_DS : fmdl->sp.Ds =val; break;
        case GIS_B0 : fmdl->sp.B0 =val; break;
        case GIS_BC : fmdl->sp.Bc =val; break;
        case GIS_BS : fmdl->sp.Bs =val; break;
        case GIS_Y0 : fmdl->sp.Y0 =val; break;
        case GIS_YC : fmdl->sp.Yc =val; break;
        case GIS_YS : fmdl->sp.Ys =val; break;
        case GIS_DC2: fmdl->sp.Dc2=val; break;
        case GIS_DS2: fmdl->sp.Ds2=val; break;
        case GIS_DC4: fmdl->sp.Dc2=val; break;
        case GIS_DS4: fmdl->sp.Ds2=val; break;
    }
}
/* get srp parameters--------------------------------------------------------*/
static double fmdlgetsrp(force_model_t *fmdl, int ip)
{
    switch (ip) {
        case GIS_D0 : return fmdl->sp.D0;
        case GIS_DC : return fmdl->sp.Dc;
        case GIS_DS : return fmdl->sp.Ds;
        case GIS_B0 : return fmdl->sp.B0;
        case GIS_BC : return fmdl->sp.Bc;
        case GIS_BS : return fmdl->sp.Bs;
        case GIS_Y0 : return fmdl->sp.Y0;
        case GIS_YC : return fmdl->sp.Yc;
        case GIS_YS : return fmdl->sp.Ys;
        case GIS_DC2: return fmdl->sp.Dc2;
        case GIS_DS2: return fmdl->sp.Ds2;
        case GIS_DC4: return fmdl->sp.Dc2;
        case GIS_DS4: return fmdl->sp.Ds2;
    }
}
/* solar radiation pressure ECOM model----------------------------------------*/
static void solradmdl_ecom(gtime_t tutc, const erpd_t *erp, const solrad_pressure_t *sp, const double *rs, const char *blocktype, double *fa, double *dadx, int uddadxmethod)
{
    force_model_t *fmdl=sp->fmdl;
    const double a0=1E-7;
    double *rmoon=fmdl->np.rr[GI_MOON];
    double *rsun=fmdl->np.rr[GI_SUN],*rsunssb=fmdl->np.rr[GI_SUNSSB];
    double *rearth=fmdl->np.rr[GI_EARTH];
    double rsun2sat[3],ru[3],vu[3],zu[3],du[3],su[3],nopu[3],yu[3],bu[3],xu[3],nodu[3];
    double sau[3],spu[3],tu[3],cosu,sinu,u,cosp,sinp,p;
    double cos1du,sin1du,cos2du,sin2du,cos4du,sin4du;
    double zaxis[3]={0,0,1};
    double distfact,lambda;
    double Du,Yu,Bu;
    int i,j;

    for (i=0;i<3;i++) fa[i]=0.0;

    if (norm(rsun   ,3)<=0.0) return;
    if (norm(rsunssb,3)<=0.0) return;
    if (norm(rmoon  ,3)<=0.0) return;
    if (norm(rearth ,3)<=0.0) return;

    for (i=0;i<3;i++) rsun2sat[i]=rs[i]-rsun[i];
    for (i=0;i<3;i++) ru[i]=rs[i]/norm(rs+0,3);
    for (i=0;i<3;i++) zu[i]=-ru[i];
    for (i=0;i<3;i++) vu[i]=rs[i+3]/norm(rs+3,3);
    for (i=0;i<3;i++) du[i]=-rsun2sat[i]/norm(rsun2sat,3);
    for (i=0;i<3;i++) su[i]=rsun[i]/norm(rsun,3);
    cross3(ru,vu,nopu);
    cross3(du,ru,yu);
    cross3(du,yu,bu);
    cross3(yu,zu,xu);
    cross3(zaxis,nopu,nodu);
    cross3(nopu,su,sau);
    cross3(sau,nopu,spu);

    cosu=dot(nodu,ru,3);
    cross3(nodu,ru,tu);
    sinu=dot(tu,nopu,3);
    u=atan2(sinu,cosu);
    cosp=dot(nodu,spu,3);
    cross3(nodu,spu,tu);
    sinp=dot(tu,nopu,3);
    p=atan2(sinp,cosp);

    cos1du=cos(1.0*(u-p));
    sin1du=sin(1.0*(u-p));
    cos2du=cos(2.0*(u-p));
    sin2du=sin(2.0*(u-p));
    cos4du=cos(4.0*(u-p));
    sin4du=sin(4.0*(u-p));

    distfact=pow(sp->Au/norm(rsun2sat,3),2.0);
    lambda=shadow(sp->shmopt,tutc,rsun,rsunssb,rmoon,rearth,rs);

    if (sp->solradmdl==SOLRAD_MODEL_ECOM1_5) {
        Du=sp->D0;
        Yu=sp->Y0;
        Bu=sp->B0+sp->Bc*cosu+sp->Bs*sinu;
    }
    else if (sp->solradmdl==SOLRAD_MODEL_ECOM1_9) {
        Du=sp->D0+sp->Dc*cosu+sp->Ds*sinu;
        Yu=sp->Y0+sp->Yc*cosu+sp->Ys*sinu;
        Bu=sp->B0+sp->Bc*cosu+sp->Bs*sinu;
    }
    else if (sp->solradmdl==SOLRAD_MODEL_ECOM2) {
        Du=sp->D0+sp->Dc2*cos2du+sp->Ds2*sin2du+sp->Dc4*cos4du+sp->Ds4*sin4du;
        Yu=sp->Y0;
        Bu=sp->B0+sp->Bc*cos1du+sp->Bs*sin1du;
    }
    else if (sp->solradmdl==SOLRAD_MODEL_ECOMC) {
        Du=sp->D0+sp->Dc*cos1du+sp->Ds*sin1du+sp->Dc2*cos2du+sp->Ds2*sin2du+sp->Dc4*cos4du+sp->Ds4*sin4du;
        Yu=sp->Y0+sp->Yc*cos1du+sp->Ys*sin1du;
        Bu=sp->B0+sp->Bc*cos1du+sp->Bs*sin1du;
    }
    for (i=0;i<3;i++) {
        fa[i]=a0*distfact*lambda*(Du*du[i]+Yu*yu[i]+Bu*bu[i]);
    }
    if (dadx) if (uddadxmethod==ACCLGRAD_ANALYSIS) {

        /* srp parameters: D0,Dc,Ds,Dc2,Ds2,Dc4,Ds4,Y0,Yc,Ys,B0,Bc,Bs */
        if (sp->solradmdl==SOLRAD_MODEL_ECOM1_5) {
            for (i=0;i<3;i++) {
                dadx[i+GIS_D0*3]=du[i];
                dadx[i+GIS_Y0*3]=yu[i];
                dadx[i+GIS_B0*3]=bu[i];
                dadx[i+GIS_BC*3]=bu[i]*cosu;
                dadx[i+GIS_BS*3]=bu[i]*sinu;
            }
        }
        else if (sp->solradmdl==SOLRAD_MODEL_ECOM1_9) {
            for (i=0;i<3;i++) {
                dadx[i+GIS_D0*3]=du[i];
                dadx[i+GIS_DC*3]=du[i]*cosu;
                dadx[i+GIS_DS*3]=du[i]*sinu;
                dadx[i+GIS_Y0*3]=yu[i];
                dadx[i+GIS_YC*3]=yu[i]*cosu;
                dadx[i+GIS_YS*3]=yu[i]*sinu;
                dadx[i+GIS_B0*3]=bu[i];
                dadx[i+GIS_BC*3]=bu[i]*cosu;
                dadx[i+GIS_BS*3]=bu[i]*sinu;
            }
        }
        else if (sp->solradmdl==SOLRAD_MODEL_ECOM2) {
            for (i=0;i<3;i++) {
                dadx[i+GIS_D0 *3]=du[i];
                dadx[i+GIS_DC2*3]=du[i]*cos2du;
                dadx[i+GIS_DS2*3]=du[i]*sin2du;
                dadx[i+GIS_DC4*3]=du[i]*cos4du;
                dadx[i+GIS_DS4*3]=du[i]*sin4du;
                dadx[i+GIS_Y0 *3]=yu[i];
                dadx[i+GIS_B0 *3]=bu[i];
                dadx[i+GIS_BC *3]=bu[i]*cos1du;
                dadx[i+GIS_BS *3]=bu[i]*sin1du;
            }
        }
        else if (sp->solradmdl==SOLRAD_MODEL_ECOMC) {
            for (i=0;i<3;i++) {
                dadx[i+GIS_D0 *3]=du[i];
                dadx[i+GIS_DC *3]=du[i]*cos1du;
                dadx[i+GIS_DS *3]=du[i]*sin1du;
                dadx[i+GIS_DC2*3]=du[i]*cos2du;
                dadx[i+GIS_DS2*3]=du[i]*sin2du;
                dadx[i+GIS_DC4*3]=du[i]*cos4du;
                dadx[i+GIS_DS4*3]=du[i]*sin4du;
                dadx[i+GIS_Y0 *3]=yu[i];
                dadx[i+GIS_YC *3]=yu[i]*cos1du;
                dadx[i+GIS_YS *3]=yu[i]*sin1du;
                dadx[i+GIS_B0 *3]=bu[i];
                dadx[i+GIS_BC *3]=bu[i]*cos1du;
                dadx[i+GIS_BS *3]=bu[i]*sin1du;
            }
        }
        for (i=0;i<3;i++) {
            for (j=GIS;j<GIS+GNS;j++) dadx[i+j*3]*=a0*distfact*lambda;
        }
    }
}
/* solar radiation pressure CODE model----------------------------------------*/
static void solradmdl_code(gtime_t tutc, const erpd_t *erp, const solrad_pressure_t *sp, const double *rs, const char *blocktype, double *fa, double *dadx, int uddadxmethod)
{
    force_model_t *fmdl=sp->fmdl;
    double *rmoon=fmdl->np.rr[GI_MOON];
    double *rsun=fmdl->np.rr[GI_SUN],*rsunssb=fmdl->np.rr[GI_SUNSSB];
    double *rearth=fmdl->np.rr[GI_EARTH];
    double rsun2sat[3],ru[3],vu[3],zu[3],su[3],eu[3],hu[3],yu[3],bu[3],xu[3],t[3];
    double beta,za[3]={0,0,1},nu[3],au[3],pu[3];
    double cosu,sinu,u,distfact,d0=1E-7;
    double lambda,Du,Yu,Bu;
    double D0,Dc,Ds,Y0,Yc,Ys,B0,Bc,Bs;
    int i;

    if (norm(rsun   ,3)<=0.0) return;
    if (norm(rsunssb,3)<=0.0) return;
    if (norm(rmoon  ,3)<=0.0) return;
    if (norm(rearth ,3)<=0.0) return;

    for (i=0;i<3;i++) rsun2sat[i]=rs[i]-rsun[i];
    for (i=0;i<3;i++) ru[i]=rs[i]/norm(rs+0,3);
    for (i=0;i<3;i++) zu[i]=-ru[i];
    for (i=0;i<3;i++) vu[i]=rs[i+3]/norm(rs+3,3);
    for (i=0;i<3;i++) su[i]=rsun2sat[i]/norm(rsun2sat,3);
    for (i=0;i<3;i++) eu[i]=rsun[i]/norm(rsun,3);

    cross3(ru,vu,t); for (i=0;i<3;i++) hu[i]=t[i]/norm(t,3);
    cross3(ru,su,t); for (i=0;i<3;i++) yu[i]=t[i]/norm(t,3);
    cross3(yu,su,t); for (i=0;i<3;i++) bu[i]=t[i]/norm(t,3);
    cross3(ru,yu,t); for (i=0;i<3;i++) xu[i]=t[i]/norm(t,3);

    beta=PI/2.0-acos(-dot(hu,eu,3));
    cross3(za,hu,t); for (i=0;i<3;i++) nu[i]=t[i]/norm(t,3);
    cross3(hu,eu,t); for (i=0;i<3;i++) au[i]=t[i]/norm(t,3);
    cross3(au,hu,t); for (i=0;i<3;i++) pu[i]=t[i]/norm(t,3);

    cosu=dot(nu,ru,3);
    cross3(nu,ru,t);
    sinu=dot(t,hu,3)>0.0?norm(t,3):-norm(t,3);
    u=atan2(sinu,cosu);
    distfact=SQR(sp->Au/norm(rsun2sat,3));

    if (strcmp(blocktype,"I")==0) {
        d0=4.54E-5/sp->mass;
    }
    else if (!strcmp(blocktype,"II")||!strcmp(blocktype,"IIA")) {
        d0=8.695E-5/sp->mass;
    }
    else if (!strcmp(blocktype,"IIR"  )||
             !strcmp(blocktype,"IIR-A")||
             !strcmp(blocktype,"IIR-B")||
             !strcmp(blocktype,"IIR-M")) {
        d0=11.15E-5/sp->mass;
    }
    else if (!strcmp(blocktype,"IIF")) {
        d0=16.7E-5/sp->mass;
    }
    else if (!strcmp(blocktype,"IIIA")) {
        d0=1.5E-7/sp->mass;
    }
    else if (!strcmp(blocktype,"BEIDOU-2M")||
             !strcmp(blocktype,"BEIDOU-3M")) {
        d0=8.35E-8/sp->mass;
    }
    else if (!strcmp(blocktype,"BEIDOU-2I")||
             !strcmp(blocktype,"BEIDOU-2G")) {
        d0=50.1E-8/sp->mass;
    }
    else if (!strcmp(blocktype,"GALILEO-1")||
             !strcmp(blocktype,"GALILEO-2")) {
        d0=8.35E-8/sp->mass;
    }
    else if (!strcmp(blocktype,"GLONASS")||
             !strcmp(blocktype,"GLONASS-M")) {
        d0=20.9E-8/sp->mass;
    }
    else if (!strcmp(blocktype,"GLONASS-K1")) {
        d0=10.0E-8/sp->mass;
    }
    else {
        d0=16.7E-8/1555.256E0;
    }
    lambda=shadow(sp->shmopt,tutc,rsun,rsunssb,rmoon,rearth,rs);

    D0=Dc=Ds=Y0=Yc=Ys=B0=Bc=Bs=0.0;
    if (sp->solradmdl==SOLRAD_MODEL_CODE_5) {
        D0=sp->D0;
        Y0=sp->Y0;
        B0=sp->B0;
        Bc=sp->Bc;
        Bs=sp->Bs;
    }
    else if (sp->solradmdl==SOLRAD_MODEL_CODE_9) {
        D0=sp->D0; Dc=sp->Bc; Ds=sp->Bs;
        Y0=sp->Y0; Yc=sp->Bc; Ys=sp->Bs;
        B0=sp->B0; Bc=sp->Bc; Bs=sp->Bs;
    }
    Du=lambda*D0+Dc*cosu+Ds*sinu;
    Yu=Y0+Yc*cosu+Ys*sinu;
    Bu=B0+Bc*cosu+Bs*sinu;
    for (i=0;i<3;i++) {
        fa[i]=d0*distfact*(Du*su[i]+Yu*yu[i]+Bu*bu[i]);
    }
    if (dadx) if (uddadxmethod==ACCLGRAD_ANALYSIS) {
        double ft=d0*distfact;

        /* srp parameters: D0,Dc,Ds,Dc2,Ds2,Dc4,Ds4,Y0,Yc,Ys,B0,Bc,Bs */
        if (sp->solradmdl==SOLRAD_MODEL_CODE_5) {
            for (i=0;i<3;i++) {
                dadx[i+GIS_D0*3]=lambda*su[i]*ft;
                dadx[i+GIS_Y0*3]=yu[i]*ft;
                dadx[i+GIS_B0*3]=bu[i]*ft;
                dadx[i+GIS_BC*3]=cosu*bu[i]*ft;
                dadx[i+GIS_BS*3]=sinu*bu[i]*ft;
            }
        }
        else if (sp->solradmdl==SOLRAD_MODEL_CODE_9) {
            for (i=0;i<3;i++) {
                dadx[i+GIS_D0*3]=lambda*su[i]*ft;
                dadx[i+GIS_DC*3]=cosu*su[i]*ft;
                dadx[i+GIS_DS*3]=sinu*su[i]*ft;
                dadx[i+GIS_Y0*3]=yu[i]*ft;
                dadx[i+GIS_YC*3]=cosu*yu[i]*ft;
                dadx[i+GIS_YS*3]=sinu*yu[i]*ft;
                dadx[i+GIS_B0*3]=bu[i]*ft;
                dadx[i+GIS_BC*3]=cosu*bu[i]*ft;
                dadx[i+GIS_BS*3]=sinu*bu[i]*ft;
            }
        }
    }
}
/* computes the acceleration due to solar radiation pressure------------------
 * assuming the spacecraft surface normal to the Sun direction
 * args   : gtime_t tutc           I  time in utc
 *          erpd_t *erp            I  earth rotation parameter data
 *          solrad_pressure_t *sp  I  solar radiation pressure model
 *          double *rs             I  satellite position (eci/m)
 *          double fa              O  acceleration due to solar radiation pressure (eci,m/s^2)
 *          double *dadx           O  partial differential of acceleration wrt to parameters
 *          int uddadxmethod       I  update method for partial differential of acceleration wrt to parameters
 * return : none
 *----------------------------------------------------------------------------*/
extern void solradpforce(gtime_t tutc, const erpd_t *erp, const solrad_pressure_t *sp, const double *rs, double *fa, double *dadx, int uddadxmethod)
{
    switch (sp->solradmdl) {
        case SOLRAD_MODEL_DEFAULT: solradmdl_deft(tutc,erp,sp,rs,sp->blocktype,fa,dadx,uddadxmethod); break;
        case SOLRAD_MODEL_ECOM1_5: solradmdl_ecom(tutc,erp,sp,rs,sp->blocktype,fa,dadx,uddadxmethod); break;
        case SOLRAD_MODEL_ECOM1_9: solradmdl_ecom(tutc,erp,sp,rs,sp->blocktype,fa,dadx,uddadxmethod); break;
        case SOLRAD_MODEL_ECOM2  : solradmdl_ecom(tutc,erp,sp,rs,sp->blocktype,fa,dadx,uddadxmethod); break;
        case SOLRAD_MODEL_ECOMC  : solradmdl_ecom(tutc,erp,sp,rs,sp->blocktype,fa,dadx,uddadxmethod); break;
        case SOLRAD_MODEL_CODE_5 : solradmdl_code(tutc,erp,sp,rs,sp->blocktype,fa,dadx,uddadxmethod); break;
        case SOLRAD_MODEL_CODE_9 : solradmdl_code(tutc,erp,sp,rs,sp->blocktype,fa,dadx,uddadxmethod); break;
        default:
            solradmdl_deft(tutc,erp,sp,rs,sp->blocktype,fa,dadx,uddadxmethod); break;
    }
    if (dadx) {
        force_model_t *fmdl=sp->fmdl;
        double fa0[3],fa1[3];
        double dp=1E-3,sp0,sp1,spp;
        int i,j;

        if (uddadxmethod==ACCLGRAD_NUMDIFF_SEP) {
            
            /* partial differential for srp parameters */
            for (i=GIS;i<GIS+GNS;i++) {
                if (!(spp=fmdlgetsrp(fmdl,i))) continue;

                sp0=spp-dp; 
                fmdlsetsrp(fmdl,i,sp0); 
                solradpforce(tutc,erp,sp,rs,fa0,NULL,0);

                sp1=spp+dp; 
                fmdlsetsrp(fmdl,i,sp1); 
                solradpforce(tutc,erp,sp,rs,fa1,NULL,0);
                
                fmdlsetsrp(fmdl,i,spp);
                for (j=0;j<3;j++) {
                    dadx[j+i*3]=(fa1[j]-fa0[j])/(2.0*dp);
                }
            }
        }
    }
}
/* computes the acceleration due to the atmospheric drag-----------------------
 * args   : gtime_t tutc           I  time in utc
 *          erpd_t *erp            I  earth rotation parameter data
 *          atmospheric_drag_t *ad I  atmospheric drag model
 *          double *rs             I  satellite position (eci/m)
 *          double fa              O  acceleration due to the atmospheric drag (m/s^2)
 *          double *dadx           O  partial differential of acceleration wrt to parameters
 *          int uddadxmethod       I  update method for partial differential of acceleration wrt to parameters
 * return: none
 *----------------------------------------------------------------------------*/
extern void atmdragforce(gtime_t tutc, const erpd_t *erp, const atmospheric_drag_t *ad, const double *rs, double *fa, double *dadx, int uddadxmethod)
{
    force_model_t *fmdl=ad->fmdl;
    const double mjd0=2400000.5;
    const double omge=7.292115146706388E-05;
    double T[3][3],NPB[9],rt[3],vt[3],t[3],ep[6],mjd_utc,mjd_tt,omg[3];
    double dens,rs_[3],erpv[5]={0};
    int i,j;

    for (i=0;i<3;i++) fa[i]=0.0;

    /* update earth rotation parameters */
    upateerpv(erp,erpv);

    time2epoch(tutc,ep);
    mjd_utc=cal2mjd(ep);
    mjd_tt=mjdtt(mjd_utc,erpv);

    iauPnm06a(mjd0,mjd_tt,T);
    for (i=0;i<3;i++) {
        for (j=0;j<3;j++) NPB[i+j*3]=T[i][j];
    }
    matmul("NN",3,1,3,1.0,NPB,rs+0,0.0,rt);
    matmul("NN",3,1,3,1.0,NPB,rs+3,0.0,vt);

    omg[0]=omg[1]=0.0;
    omg[2]=omge-0.843994809*1E-9*erp->lod;
    cross3(omg,rt,t);
    vt[0]=vt[0]-t[0];
    vt[1]=vt[1]-t[1];
    vt[2]=vt[2]-t[2];

    if (ad->atmdensopt==ATMODENSITY_HPM) {
        matmul("NN",3,1,3,1.0,NPB,rs,0.0,rs_);
    }
    else if (ad->atmdensopt==ATMODENSITY_NRL) {
        double U[9];
        ecsf2ecef(tutc,erpv,U,NULL,NULL);
        matmul("NN",3,1,3,1.0,U,rs,0.0,rs_);
    }
    /* atmospheric density */
    dens=atmdens(ad,ad->atmdensopt,mjd_utc,erpv,fmdl->np.rr[GI_SUN],rs_);

    t[0]=-0.5*ad->CD*ad->area/ad->mass*dens*norm(vt,3)*vt[0];
    t[1]=-0.5*ad->CD*ad->area/ad->mass*dens*norm(vt,3)*vt[1];
    t[2]=-0.5*ad->CD*ad->area/ad->mass*dens*norm(vt,3)*vt[2];
    matmul("TN",3,1,3,1.0,NPB,t,0.0,fa);

    if (dadx) {
        if (uddadxmethod==ACCLGRAD_NUMDIFF_SEP) {
            double dr=0.001,dv=0.001;
            double r0[6],r1[6];
            double fa0[3],fa1[3];

            /* partial differential for position */
            for (i=0;i<3;i++) {
                matcpy(r0,rs,1,6);
                matcpy(r1,rs,1,6);
                r0[GIP+i]-=dr;
                r1[GIP+i]+=dr;

                atmdragforce(tutc,erp,ad,r0,fa0,NULL,0);
                atmdragforce(tutc,erp,ad,r1,fa1,NULL,0);
                for (j=0;j<3;j++) {
                    dadx[j+(GIP+i)*3]=(fa1[j]-fa0[j])/(2.0*dr);
                }
            }
            /* partial differential for velocity */
            for (i=0;i<3;i++) {
                matcpy(r0,rs,1,6);
                matcpy(r1,rs,1,6);
                r0[GIV+i]-=dv;
                r1[GIV+i]+=dv;

                atmdragforce(tutc,erp,ad,r0,fa0,NULL,0);
                atmdragforce(tutc,erp,ad,r1,fa1,NULL,0);
                for (j=0;j<3;j++) {
                    dadx[j+(GIV+i)*3]=(fa1[j]-fa0[j])/(2.0*dv);
                }
            }
        }
        else if (uddadxmethod==ACCLGRAD_ANALYSIS) {
            double vn=norm(vt,3),dtdv[9];
            double fact=-0.5*ad->CD*ad->area/ad->mass*dens;

            dtdv[0+0*3]=vn+SQR(vt[0])/vn;
            dtdv[1+0*3]=vt[0]*vt[1]/vn;
            dtdv[2+0*3]=vt[0]*vt[2]/vn;

            dtdv[0+1*3]=vt[0]*vt[1]/vn;
            dtdv[1+1*3]=vn+SQR(vt[1])/vn;
            dtdv[2+1*3]=vt[1]*vt[2]/vn;

            dtdv[0+2*3]=vt[0]*vt[2]/vn;
            dtdv[1+2*3]=vt[1]*vt[2]/vn;
            dtdv[2+2*3]=vn+SQR(vt[2])/vn;

            double dvdv[9],dvdp[9],P[9];
            matcpy(dvdv,NPB,3,3);
            skewsym3(omg,P);
            matmul("NN",3,3,3,-1.0,P,NPB,0.0,dvdp);

            double dadv[9],dadp[9];
            matmul("NN",3,3,3,1.0,dtdv,dvdv,0.0,P);
            matmul("TN",3,3,3,fact,NPB,P,0.0,dadv);

            matmul("NN",3,3,3,1.0,dtdv,dvdp,0.0,P);
            matmul("TN",3,3,3,fact,NPB,P,0.0,dadp);

            for (i=0;i<3;i++) {
                for (j=GIP;j<GIP+3;j++) dadx[i+j*3]=dadp[i+(j-GIP)*3];
                for (j=GIV;j<GIV+3;j++) dadx[i+j*3]=dadv[i+(j-GIV)*3];
            }
        }
    }
}
/* computes the perturbational acceleration due to a point mass-----------------
 * args:    double *rs        I  satellite position (eci/m)
 *          double *rr        I  point mass position (eci/m)
 *          double  GM        I  gravitational coefficient of point mass
 *          double *fa        O  perturbational acceleration (eci,m/s^2)
 *          double *dadx      O  partial differential of acceleration wrt to parameters
 *          int uddadxmethod  I  update method for partial differential of acceleration wrt to parameters
 * return : none
 *-----------------------------------------------------------------------------*/
static void pointmassforce(const double *rs, const double *rr, double GM, double *fa, double *dadx, int uddadxmethod)
{
    double t,p,dr[3];
    int i,j;

    for (i=0;i<3;i++) fa[i]=0.0;
    for (i=0;i<3;i++) dr[i]=rs[i]-rr[i];
    t=norm(dr,3);
    p=norm(rr,3);
    fa[0]=-GM*(dr[0]/pow(t,3)+rr[0]/pow(p,3));
    fa[1]=-GM*(dr[1]/pow(t,3)+rr[1]/pow(p,3));
    fa[2]=-GM*(dr[2]/pow(t,3)+rr[2]/pow(p,3));

    if (dadx) {
        double s3=pow(t,3);
        double s5=pow(t,5);

        /* compute partial differential using numerical differential */
        if (uddadxmethod==ACCLGRAD_NUMDIFF_SEP) {
            double r0[6],r1[6],dp=0.001;
            double fa0[3],fa1[3];

            /* partial differential for position */
            for (i=0;i<3;i++) {
                matcpy(r0,rs,1,6);
                matcpy(r1,rs,1,6);
                r0[GIP+i]-=dp;
                r1[GIP+i]+=dp;

                pointmassforce(r0,rr,GM,fa0,NULL,0);
                pointmassforce(r1,rr,GM,fa1,NULL,0);
                for (j=0;j<3;j++) {
                    dadx[j+(GIP+i)*3]=(fa1[j]-fa0[j])/(2.0*dp);
                }
            }
        }
        /* compute partial differential using analysis formula*/
        else if (uddadxmethod==ACCLGRAD_ANALYSIS) {
            dadx[0+(GIP+0)*3]=GM*(1.0/s3-3.0*dr[0]*dr[0]/s5);
            dadx[1+(GIP+0)*3]=-3.0*GM*dr[0]*dr[1]/s5;
            dadx[2+(GIP+0)*3]=-3.0*GM*dr[0]*dr[2]/s5;

            dadx[0+(GIP+1)*3]=-3.0*GM*dr[1]*dr[0]/s5;
            dadx[1+(GIP+1)*3]=GM*(1.0/s3-3.0*dr[1]*dr[1]/s5);
            dadx[2+(GIP+1)*3]=-3.0*GM*dr[1]*dr[2]/s5;

            dadx[0+(GIP+2)*3]=-3.0*GM*dr[2]*dr[0]/s5;
            dadx[1+(GIP+2)*3]=-3.0*GM*dr[2]*dr[1]/s5;
            dadx[2+(GIP+2)*3]=GM*(1.0/s3-3.0*dr[2]*dr[2]/s5);
        }
    }
}
/* N-body perturbation----------------------------------------------------------
 * args   : gtime_t tutc             I  time in utc
 *          erpd_t *erp              I  earth rotation parameter data
 *          nbody_perturbation_t *np I  N-body perturbation model
 *          double *rs               I  satellite position (eci/m)
 *          double fa                O  acceleration due to N-body perturbation (m/s^2)
 *          double *dadx             O  partial differential of acceleration wrt to parameters
 *          int uddadxmethod         I  update method for partial differential of acceleration wrt to parameters
 * return : none
 *----------------------------------------------------------------------------*/
extern void nbpertnforce(gtime_t tutc, const erpd_t *erp, nbody_perturbation_t *np, const double *rs, double *fa, double *dadx, int uddadxmethod)
{
    double erpv[5]={0},at[3];
    double dadxs[GNX*3]={0};

    /* update earth rotation parameters */
    upateerpv(erp,erpv);

    /* nine major planets' equatorial position */
    jpleph_de440(tutc,erpv,np->rr[GI_MERCURY],
                           np->rr[GI_VENUS  ],
                           np->rr[GI_EARTH  ],
                           np->rr[GI_MARS   ],
                           np->rr[GI_JUPITER],
                           np->rr[GI_SATURN ],
                           np->rr[GI_URANUS ],
                           np->rr[GI_NEPTUNE],
                           np->rr[GI_PLUTO  ],
                           np->rr[GI_MOON   ],
                           np->rr[GI_SUN    ],
                           np->rr[GI_SUNSSB]);

    int i,j,k;
    for (i=0;i<3;i++) fa[i]=0.0;
    for (i=0;i<10;i++) {
        pointmassforce(rs,np->rr[i],np->rr[i][3],at,dadx?dadxs:NULL,uddadxmethod);
        for (j=0;j<3;j++) fa[j]+=at[j];

        if (dadx) {
            for (j=0;j<3;j++) {
                for (k=0;k<GNX;k++) dadx[j+k*3]+=dadxs[j+k*3];
            }
        }
    }
}
/* partial differential of relativistic effects force wrt to position---------*/
static void reldadp(gtime_t tutc, const double *fa, const double *rs, double *dadx)
{
    const double R_E=6378136.3;
    const double GM_E=398600.4415E9;
    double rt=norm(rs+0,3);
    double vt=norm(rs+3,3);
    double t3=pow(rt,3);
    double t5=pow(rt,5);
    double rx=rs[0];
    double ry=rs[1];
    double rz=rs[2];
    double vx=rs[3];
    double vy=rs[4];
    double vz=rs[5];
    double s1=4.0*dot(rs,rs+3,3);
    double s2=SQR(vt)-4.0*GM_E/rt;
    double s3=SQR(CLIGHT)*t5;
    double s4=SQR(CLIGHT)*t3;
    double s5=4.0*GM_E/rt;

    dadx[0+(GIP+0)*3]=-GM_E*((SQR(vy)-3.0*SQR(vx)+SQR(vz)-s5+4.0*GM_E*SQR(rx)/t3)/s4+3.0*rx*(vx*s1-rx*s2)/s3);
    dadx[1+(GIP+0)*3]= GM_E*((4.0*vx*vy-4.0*GM_E*rx*ry/t3)/s4-3.0*rx*(vy*s1-ry*s2)/s3);
    dadx[2+(GIP+0)*3]= GM_E*((4.0*vx*vz-4.0*GM_E*rx*rz/t3)/s4-3.0*rx*(vz*s1-rz*s2)/s3);

    dadx[0+(GIP+1)*3]= GM_E*((4.0*vx*vy-4.0*GM_E*rx*ry/t3)/s4-3.0*ry*(vx*s1-rx*s2)/s3);
    dadx[1+(GIP+1)*3]=-GM_E*((SQR(vx)-3.0*SQR(vy)+SQR(vz)-s5+4.0*GM_E*SQR(ry)/t3)/s4+3.0*ry*(vy*s1-ry*s2)/s3);
    dadx[2+(GIP+1)*3]= GM_E*((4.0*vy*vz-4.0*GM_E*ry*rz/t3)/s4-3.0*ry*(vz*s1-rz*s2)/s3);

    dadx[0+(GIP+2)*3]= GM_E*((4.0*vx*vz-4.0*GM_E*rx*rz/t3)/s4-3.0*rz*(vx*s1-rx*s2)/s3);
    dadx[1+(GIP+2)*3]= GM_E*((4.0*vy*vz-4.0*GM_E*ry*rz/t3)/s4-3.0*rz*(vy*s1-ry*s2)/s3);
    dadx[2+(GIP+2)*3]=-GM_E*((SQR(vx)-3.0*SQR(vz)+SQR(vy)-s5+4.0*GM_E*SQR(rz)/t3)/s4+3.0*rz*(vz*s1-rz*s2)/s3);
}
/* partial differential of relativistic effects force wrt to velocity---------*/
static void reldadv(gtime_t tutc, const double *fa, const double *rs, double *dadx)
{
    const double R_E=6378136.3;
    const double GM_E=398600.4415E9;
    double rx=rs[0];
    double ry=rs[1];
    double rz=rs[2];
    double vx=rs[3];
    double vy=rs[4];
    double vz=rs[5];
    double s1=SQR(CLIGHT)*pow(norm(rs,3),3);

    dadx[0+(GIV+0)*3]= GM_E*(6.0*rx*vx+4.0*ry*vy+4.0*rz*vz)/s1;
    dadx[1+(GIV+0)*3]= GM_E*(4.0*rx*vy-2.0*ry*vx)/s1;
    dadx[2+(GIV+0)*3]= GM_E*(4.0*rx*vz-2.0*rz*vx)/s1;

    dadx[0+(GIV+1)*3]=-GM_E*(2.0*rx*vy-4.0*ry*vx)/s1;
    dadx[1+(GIV+1)*3]= GM_E*(4.0*rx*vx+6.0*ry*vy+4.0*rz*vz)/s1;
    dadx[2+(GIV+1)*3]= GM_E*(4.0*ry*vz-2.0*rz*vy)/s1;

    dadx[0+(GIV+2)*3]=-GM_E*(2.0*rx*vz-4.0*rz*vx)/s1;
    dadx[1+(GIV+2)*3]=-GM_E*(2.0*ry*vz-4.0*rz*vy)/s1;
    dadx[2+(GIV+2)*3]= GM_E*(4.0*rx*vx+4.0*ry*vy+6.0*rz*vz)/s1;
}
/* relativistic effects force-------------------------------------------------*/
extern void relattyforce(gtime_t tutc, const erpd_t *erp, const relatvty_mode_t *rl, const double *rs, double *fa, double *dadx, int uddadxmethod)
{
    force_model_t *fmdl=rl->fmdl;
    const double R_E=6378136.3;
    const double GM_E=398600.4415E9;
    double rt=norm(rs+0,3);
    double vt=norm(rs+3,3);

    fa[0]=GM_E/(SQR(CLIGHT)*pow(rt,3))*((4.0*GM_E/rt-SQR(vt))*rs[0]+4.0*dot(rs,rs+3,3)*rs[3]);
    fa[1]=GM_E/(SQR(CLIGHT)*pow(rt,3))*((4.0*GM_E/rt-SQR(vt))*rs[1]+4.0*dot(rs,rs+3,3)*rs[4]);
    fa[2]=GM_E/(SQR(CLIGHT)*pow(rt,3))*((4.0*GM_E/rt-SQR(vt))*rs[2]+4.0*dot(rs,rs+3,3)*rs[5]);

    if (dadx) {
        if (uddadxmethod==ACCLGRAD_NUMDIFF_SEP) {
            double dr=0.001,dv=0.001;
            double r0[6],r1[6],fa0[3],fa1[3];
            int i,j;

            /* partial differential for position */
            for (i=0;i<3;i++) {
                matcpy(r0,rs,1,6);
                matcpy(r1,rs,1,6);
                r0[GIP+i]-=dr;
                r1[GIP+i]+=dr;

                relattyforce(tutc,erp,rl,r0,fa0,NULL,0);
                relattyforce(tutc,erp,rl,r1,fa1,NULL,0);
                for (j=0;j<3;j++) {
                    dadx[j+(GIP+i)*3]=(fa1[j]-fa0[j])/(2.0*dr);
                }
            }
            /* partial differential for velocity */
            for (i=0;i<3;i++) {
                matcpy(r0,rs,1,6);
                matcpy(r1,rs,1,6);
                r0[GIV+i]-=dv;
                r1[GIV+i]+=dv;

                relattyforce(tutc,erp,rl,r0,fa0,NULL,0);
                relattyforce(tutc,erp,rl,r1,fa1,NULL,0);
                for (j=0;j<3;j++) {
                    dadx[j+(GIV+i)*3]=(fa1[j]-fa0[j])/(2.0*dv);
                }
            }
        }
        else if (uddadxmethod==ACCLGRAD_ANALYSIS) {
            reldadp(tutc,fa,rs,dadx);
            reldadv(tutc,fa,rs,dadx);   
        }
    }
}
/* satellite force model------------------------------------------------------
 * args:    force_model_t *fmdl  IO satellite force model
 *          gtime_t tutc         I  time in utc
 *          erpd_t *erp          I  earth rotation parameter data
 *          double *rs           I  satellite position (eci/m)
 *          double *fa           O  satellite acceleration (eci,m/s^2)
 *          double *dadx         O  partial differential of acceleration wrt to parameters
 * return: none
 * --------------------------------------------------------------------------*/
extern void satforce(force_model_t *fmdl, gtime_t tutc, const erpd_t *erp, const double *rs, double *fa, double *dadx)
{
    double dadxn[GNX*3]={0};
    double dadxa[GNX*3]={0};
    double dadxs[GNX*3]={0};
    double dadxg[GNX*3]={0};
    double dadxr[GNX*3]={0};
    double fagm[3]={0};
    double fasp[3]={0};
    double faad[3]={0};
    double fanp[3]={0};
    double fare[3]={0};
    int i,j;

    nbpertnforce(tutc,erp,&fmdl->np,rs,fanp,dadx?dadxn:NULL,fmdl->opt.udacclgrad);
    atmdragforce(tutc,erp,&fmdl->ad,rs,faad,dadx?dadxa:NULL,fmdl->opt.udacclgrad);
    solradpforce(tutc,erp,&fmdl->sp,rs,fasp,dadx?dadxs:NULL,fmdl->opt.udacclgrad);
    gravityforce(tutc,erp,&fmdl->gm,rs,fagm,dadx?dadxg:NULL,fmdl->opt.udacclgrad);
    relattyforce(tutc,erp,&fmdl->rt,rs,fare,dadx?dadxr:NULL,fmdl->opt.udacclgrad);

    for (i=0;i<3;i++) {
        fa[i]=fagm[i]+fasp[i]+faad[i]+fanp[i]+fare[i];
    }
    if (dadx) {
        if (fmdl->opt.udacclgrad==ACCLGRAD_ANALYSIS||fmdl->opt.udacclgrad==ACCLGRAD_NUMDIFF_SEP) {
            for (i=0;i<3;i++) {
                for (j=0;j<GNX;j++) dadx[i+j*3]+=dadxn[i+j*3];
                for (j=0;j<GNX;j++) dadx[i+j*3]+=dadxa[i+j*3];
                for (j=0;j<GNX;j++) dadx[i+j*3]+=dadxs[i+j*3];
                for (j=0;j<GNX;j++) dadx[i+j*3]+=dadxg[i+j*3];
                for (j=0;j<GNX;j++) dadx[i+j*3]+=dadxr[i+j*3];
            }
        }
        else if (fmdl->opt.udacclgrad==ACCLGRAD_NUMDIFF_ALL) {
            double rs0[6],rs1[6],dr=0.001,dv=0.001,dp=1E-3,sp0,sp1,spp;
            double fa0[3],fa1[3];

            /* partial differential for position */
            for (i=0;i<3;i++) {
                matcpy(rs0,rs,1,6);
                matcpy(rs1,rs,1,6);
                rs0[GIP+i]-=dr;
                rs1[GIP+i]+=dr;

                satforce(fmdl,tutc,erp,rs0,fa0,NULL);
                satforce(fmdl,tutc,erp,rs1,fa1,NULL);
                for (j=0;j<3;j++) {
                    dadx[j+(GIP+i)*3]=(fa1[j]-fa0[j])/(2.0*dr);
                }
            }
            /* partial differential for velocity */
            for (i=0;i<3;i++) {
                matcpy(rs0,rs,1,6);
                matcpy(rs1,rs,1,6);
                rs0[GIV+i]-=dv;
                rs1[GIV+i]+=dv;

                satforce(fmdl,tutc,erp,rs0,fa0,NULL);
                satforce(fmdl,tutc,erp,rs1,fa1,NULL);
                for (j=0;j<3;j++) {
                    dadx[j+(GIV+i)*3]=(fa1[j]-fa0[j])/(2.0*dv);
                }
            }
            /* partial differential for srp parameters */
            for (i=GIS;i<GIS+GNS;i++) {
                if (!(spp=fmdlgetsrp(fmdl,i))) continue;

                sp0=spp-dp; fmdlsetsrp(fmdl,i,sp0); satforce(fmdl,tutc,erp,rs,fa0,NULL);
                sp1=spp+dp; fmdlsetsrp(fmdl,i,sp1); satforce(fmdl,tutc,erp,rs,fa1,NULL);

                fmdlsetsrp(fmdl,i,spp);
                for (j=0;j<3;j++) {
                    dadx[j+i*3]=(fa1[j]-fa0[j])/(2.0*dp);
                }
            }
        }
    }
}
/* GNSS orbit differential equations ----------------------------------------*/
static int orbitdeq(double t, const double *x, double *f, void *param)
{
    double r2=dot(x,x,3),erpv[6];
    satorbit_t *orbit=param;
    gtime_t tutc;
    erpd_t erpd={0};

    tutc=timeadd(orbit->tutc,t);
    if (r2<=0.0) {
        f[0]=f[1]=f[2]=f[3]=f[4]=f[5]=0.0;
        return GSL_FAILURE;
    }
#if 1
    geterp(&orbit->fmdl.erp,utc2gpst(tutc),erpv);
    erpd.mjd=time2mjd(tutc);
    erpd.xp=erpv[0];
    erpd.yp=erpv[1];
    erpd.ut1_utc=erpv[2];
    erpd.lod=erpv[3];
    erpd.tai_utc=erpv[4];
#else
    geteop(&orbit->fmdl.erp,tutc,&erpd);
#endif
    /* satellite velocity */
    f[0]=x[3];
    f[1]=x[4];
    f[2]=x[5];

    if (orbit->fmdl.opt.udtransmatrix==UDTRANSMATRIX_INTGRTN) {
        double dadx[3*GNX]={0},A[GNX*GNX]={0},F[GNX*GNX]={0},Ft[GNX*GNX];
        double I[9]={1,0,0,0,1,0,0,0,1};
        int i,j,nx=GNX;

        /* satellite acceleration and partial differential */
        satforce(&orbit->fmdl,tutc,&erpd,x,f+3,dadx);

        /* update transition matrix using numerical integration
         * transition matrix, (6+np,6+np)
         *       |                           |
         *       |   dr/dr0  dr/dv0  dr/dp0  |
         *       |                           |
         * phi = |   dv/dr0  dv/dv0  dv/dp0  |
         *       |                           |
         *       |   0       0       I       |
         *       |                           |
         *
         * design matrix, (6+np,6+np)
         *     |                           |
         *     |   0       I       0       |
         *     |                           |
         * A = |   da/dr   da/dv   da/dp   |
         *     |                           |
         *     |   0       0       0       |
         *     |                           |
         * dot of transition matrix, (6+np,6+np)
         *        |                          |
         *        |  dv/dr0  dv/dv0  dv/dp0  |
         *        |                          |
         * dphi = |  da/dr0  da/dv0  da/dp0  | = A * phi
         *        |                          |
         *        |  0       0       0       |
         *        |                          |
         * */
        for (i=0;i<3;i++) {
            for (j=GIV;j<GIV+GNV;j++) A[GIP+i+j*nx]=I[i+(j-GIV)*3];
            for (j=GIP;j<GIP+GNX;j++) A[GIV+i+j*nx]=dadx[i+j*3];
        }
        for (i=0;i<nx;i++) {
            for (j=0;j<nx;j++) {
                F[i+j*nx]=x[6+i+j*nx];
            }
        }
        matmul("NN",nx,nx,nx,1.0,A,F,0.0,Ft);
        for (i=0;i<nx;i++) {
            for (j=0;j<nx;j++) {
                f[6+i+j*nx]=Ft[i+j*nx];
            }
        }
    }
    else {
        satforce(&orbit->fmdl,tutc,&erpd,x,f+3,NULL);
    }
    return GSL_SUCCESS;
}
/* initial satellite orbit--------------------------------------------------*/
extern void satorbitinit(satorbit_t *orbit, const force_model_opt_t *opt, const double *x0, gtime_t tutc0)
{
    forcemdlinit(&orbit->fmdl,opt);
    orbit->tutc=tutc0;
    matcpy(orbit->x,x0,1,6);

    int i,j;

    /* srp parameters: D0,Dc,Ds,Dc2,Ds2,Dc4,Ds4,Y0,Yc,Ys,B0,Bc,Bs */
    orbit->x[GIS_D0 ]=opt->D0;
    orbit->x[GIS_DC ]=opt->Dc;
    orbit->x[GIS_DS ]=opt->Ds;
    orbit->x[GIS_DC2]=opt->Dc2;
    orbit->x[GIS_DS2]=opt->Ds2;
    orbit->x[GIS_DC4]=opt->Dc4;
    orbit->x[GIS_DS4]=opt->Ds4;
    orbit->x[GIS_Y0 ]=opt->Y0;
    orbit->x[GIS_YC ]=opt->Yc;
    orbit->x[GIS_YS ]=opt->Ys;
    orbit->x[GIS_B0 ]=opt->B0;
    orbit->x[GIS_BC ]=opt->Bc;
    orbit->x[GIS_BS ]=opt->Bs;

    for (i=0;i<GNX;i++) {
        for (j=0;j<GNX;j++) {
            orbit->F[i+j*GNX]=i==j?1.0:0.0;
        }
    }
}
/* free satellite orbit------------------------------------------------------*/
extern void satorbitfree(satorbit_t *orbit)
{
    forcemdlfree(&orbit->fmdl);
    memset(orbit,0,sizeof(*orbit));
}
/* satellite orbit propagator-------------------------------------------------
 * args:    satorbit_t *orbit   IO  satellite orbit
 *          int method          I   satellite orbit propagator method
 *          double dt           I   satellite orbit propagator time interval
 * return : status (0:fail,1:ok)
 * --------------------------------------------------------------------------*/
static int satorbit_gslode(int method, satorbit_t *orbit, const double dt)
{
    int i,j,stat,nx=orbit->fmdl.opt.udtransmatrix==UDTRANSMATRIX_INTGRTN?6+GNX*GNX:6;
    gsl_odeiv2_system system={
            orbitdeq,
            NULL,
            nx,
            orbit
    };
    const gsl_odeiv2_step_type *step_type=gsl_odeiv2_step_rk8pd;
    double step=0.01,err=1E-10,h=step,t1=dt,t=0.0,tt;
    double hmax=MAX(fabs(dt),step),*xt;

    xt=mat(1,nx);

    switch (method) {
        case ORBITINT_GSLODE_RK8PD  : step_type=gsl_odeiv2_step_rk8pd  ; break;
        case ORBITINT_GSLODE_RKF45  : step_type=gsl_odeiv2_step_rkf45  ; break;
        case ORBITINT_GSLODE_MSADAMS: step_type=gsl_odeiv2_step_msadams; break;
        case ORBITINT_GSLODE_MSBDF  : step_type=gsl_odeiv2_step_msbdf  ; break;
    }
    if (t1<0.0) h=-step;
    matcpy(xt,orbit->x,1,6);

    for (i=0;i<GNX;i++) {
        for (j=0;j<GNX;j++) {
            orbit->F[i+j*GNX]=i==j?1.0:0.0;
        }
    }
    if (orbit->fmdl.opt.udtransmatrix==UDTRANSMATRIX_INTGRTN) {
        for (i=0;i<GNX;i++) {
            for (j=0;j<GNX;j++) {
                xt[6+i+j*GNX]=orbit->F[i+j*GNX];
            }
        }
    }
    gsl_odeiv2_driver *driver=gsl_odeiv2_driver_alloc_standard_new(&system,step_type,h,err,err,1.0,0.0);
    gsl_odeiv2_driver_set_hmax(driver,hmax);

    stat=gsl_odeiv2_driver_apply(driver,&t,t1,xt);
    gsl_odeiv2_driver_free(driver);

    if (stat!=GSL_SUCCESS) {
        free(xt);
        return 0;
    }
    matcpy(orbit->x,xt,1,6);

    if (orbit->fmdl.opt.udtransmatrix==UDTRANSMATRIX_INTGRTN) {
        for (i=0;i<GNX;i++) {
            for (j=0;j<GNX;j++) {
                orbit->F[i+j*GNX]=xt[6+i+j*GNX];
            }
        }
    }
    orbit->tutc=timeadd(orbit->tutc,dt);
    free(xt);
    return 1;
}
/* satellite orbit propagator using RKF78m------------------------------------*/
static int satorbit_rkf78m(int method, satorbit_t *orbit, const double dt)
{
    int i,j,nx=orbit->fmdl.opt.udtransmatrix==UDTRANSMATRIX_INTGRTN?6+GNX*GNX:6;
    double *x0,*xt,h=0.01,err=1E-10;

    x0=mat(1,nx);
    xt=mat(1,nx);
    matcpy(x0,orbit->x,1,6);

    if (fabs(dt)<h) h=fabs(dt);

    for (i=0;i<GNX;i++) {
        for (j=0;j<GNX;j++) {
            orbit->F[i+j*GNX]=i==j?1.0:0.0;
        }
    }
    if (orbit->fmdl.opt.udtransmatrix==UDTRANSMATRIX_INTGRTN) {
        for (i=0;i<GNX;i++) {
            for (j=0;j<GNX;j++) {
                x0[6+i+j*GNX]=orbit->F[i+j*GNX];
            }
        }
    }
    if (rkf78m(orbitdeq,orbit,x0,0.0,h,dt,err,xt,nx)!=1) {
        free(x0); free(xt);
        return 0;
    }
    matcpy(orbit->x,xt,1,6);

    if (orbit->fmdl.opt.udtransmatrix==UDTRANSMATRIX_INTGRTN) {
        for (i=0;i<GNX;i++) {
            for (j=0;j<GNX;j++) {
                orbit->F[i+j*GNX]=xt[6+i+j*GNX];
            }
        }
    }
    orbit->tutc=timeadd(orbit->tutc,dt);
    free(x0); free(xt);
    return 1;
}
/* satellite orbit propagator using odeint-v2---------------------------------*/
static int satorbit_odeint(int method, satorbit_t *orbit, const double dt)
{
    int nx=orbit->fmdl.opt.udtransmatrix==UDTRANSMATRIX_INTGRTN?6+GNX*GNX:6;
    odeint_t odeint={
            orbitdeq,
            nx,
            orbit
    };
    double te=dt,ts=0.0;
    double *xt;
    int i,j;

    for (i=0;i<GNX;i++) {
        for (j=0;j<GNX;j++) {
            orbit->F[i+j*GNX]=i==j?1.0:0.0;
        }
    }
    xt=mat(1,nx);
    matcpy(xt,orbit->x,1,6);

    if (orbit->fmdl.opt.udtransmatrix==UDTRANSMATRIX_INTGRTN) {
        for (i=0;i<GNX;i++) {
            for (j=0;j<GNX;j++) {
                xt[6+i+j*GNX]=orbit->F[i+j*GNX];
            }
        }
    }
    if (!odeintv2(method,&odeint,dt,xt,nx)) {
        free(xt);
        return 0;
    }
    matcpy(orbit->x,xt,1,6);
    if (orbit->fmdl.opt.udtransmatrix==UDTRANSMATRIX_INTGRTN) {
        for (i=0;i<GNX;i++) {
            for (j=0;j<GNX;j++) {
                orbit->F[i+j*GNX]=xt[6+i+j*GNX];
            }
        }
    }
    orbit->tutc=timeadd(orbit->tutc,dt);
    free(xt);
    return 1;
}
/* satellite orbit propagator process-----------------------------------------*/
static int satorbitprc(int method, satorbit_t *orbit, const double dt)
{
    switch (method) {
        case ORBITINT_GSLODE_RK8PD  : return satorbit_gslode(method,orbit,dt);
        case ORBITINT_GSLODE_RKF45  : return satorbit_gslode(method,orbit,dt);
        case ORBITINT_GSLODE_MSADAMS: return satorbit_gslode(method,orbit,dt);
        case ORBITINT_GSLODE_MSBDF  : return satorbit_gslode(method,orbit,dt);
        case ORBITINT_RKF78M        : return satorbit_rkf78m(method,orbit,dt);
        case ORBITINT_ODEINTV2_ADAMSADAMS: return satorbit_odeint(0,orbit,dt);
        case ORBITINT_ODEINTV2_CONMSADAMS: return satorbit_odeint(1,orbit,dt);
        case ORBITINT_ODEINTV2_RKF78     : return satorbit_odeint(2,orbit,dt);
        case ORBITINT_ODEINTV2_RK_CASH_KARP54: return satorbit_odeint(3,orbit,dt);
        default:
            return satorbit_rkf78m(method,orbit,dt);
    }
}
/* satellite orbit propagator ------------------------------------------------*/
extern int satorbit(int method, satorbit_t *orbit, double dt)
{
    gtime_t t0=orbit->tutc;
    double x0[GNX]={0},corrtime=3600.0;

    orbitgetx(orbit,x0);
    satorbitprc(method,orbit,dt);
    orbitgetx(orbit,orbit->x);

    /* transition matrix by numerical differential */
    if (orbit->fmdl.opt.udtransmatrix==UDTRANSMATRIX_NUMDIF_2P||orbit->fmdl.opt.udtransmatrix==UDTRANSMATRIX_NUMDIF_3P) {

        double xt0[GNX]={0},xt[GNX]={0},dh[GNX];
        double x1[GNX]={0},x2[GNX]={0},F[GNX*GNX]={0};
        int i,j;

        orbitgetx(orbit,xt);
        gtime_t tt=orbit->tutc;

        for (i=GIP;i<GIP+GNP;i++) dh[i]=0.001;
        for (i=GIV;i<GIV+GNV;i++) dh[i]=0.001;
        for (i=GIS;i<GIS+GNS;i++) dh[i]=1E-3;
        for (i=GIC;i<GIC+GNC;i++) dh[i]=1E-3;

        for (i=0;i<GNX;i++) {
            for (j=0;j<GNX;j++) {
                F[i+j*GNX]=i==j?1.0:0.0;
            }
        }
        /* update transition matrix */
        for (i=0;i<GNX;i++) {
            if (!x0[i]) continue;

            /* numerical differential: two-points */
            if (orbit->fmdl.opt.udtransmatrix==UDTRANSMATRIX_NUMDIF_2P) {

                orbit->tutc=t0;
                matcpy(xt0,x0,1,GNX);
                xt0[i]+=dh[i];

                orbitsetx(xt0,orbit);
                satorbitprc(method,orbit,dt);
                orbitgetx(orbit,x1);

                for (j=0;j<GNX;j++) {
                    F[j+i*GNX]=(x1[j]-xt[j])/dh[j];
                }
            }
            /* numerical differential: three-points */
            else if (orbit->fmdl.opt.udtransmatrix==UDTRANSMATRIX_NUMDIF_3P) {

                orbit->tutc=t0;
                matcpy(xt0,x0,1,GNX);
                xt0[i]+=dh[i];

                orbitsetx(xt0,orbit);
                satorbitprc(method,orbit,dt);
                orbitgetx(orbit,x1);

                orbit->tutc=t0;
                matcpy(xt0,x0,1,GNX);
                xt0[i]-=dh[i];

                orbitsetx(xt0,orbit);
                satorbitprc(method,orbit,dt);
                orbitgetx(orbit,x2);

                for (j=0;j<GNX;j++) {
                    F[j+i*GNX]=(x1[j]-x2[j])/(2.0*dh[j]);
                }
            }
        }
        /* update current satellite orbit */
        orbit->tutc=tt;
        orbitsetx(xt,orbit);
        matcpy(orbit->F,F,GNX,GNX);
    }
    /* satellite clock transition matrix */
    orbit->F[GICR+GICR*GNX]=exp(-fabs(dt)/corrtime);
    orbit->F[GIC +GICR*GNX]=corrtime-corrtime*exp(-fabs(dt)/corrtime);

    log_trace(4,"time=%s F=\n",time_str(orbit->tutc,3));
    log_tracemat(4,orbit->F,GNX,GNX,25,18);
    return 1;
}
extern int satorbite(int method, satorbit_t *orbit, double dt, double *x, double *F)
{
    gtime_t tutc;
    int state;
    double x0[GNX],F0[GNX*GNX];

    tutc=orbit->tutc;
    state=orbit->state;
    matcpy(x0,orbit->x,  1,GNX);
    matcpy(F0,orbit->F,GNX,GNX);

    satorbit(method,orbit,dt);

    matcpy(x,orbit->x,  1,GNX);
    matcpy(F,orbit->F,GNX,GNX);

    orbit->tutc=tutc;
    orbit->state=state;
    matcpy(orbit->x,x0,  1,GNX);
    matcpy(orbit->F,F0,GNX,GNX);
    return 1;
}
/* compute diurnal/subdiurnal tidal effects on polar motion("),UT1(s)---------
 * and LOD(s) in time domain, IERS conventions 2010
 *---------------------------------------------------------------------------*/
extern void pmut1_ocean(gtime_t tutc, double *cor)
{
    static const struct {
        int nchi;             /* coefficients of GMST+PI */
        int n1,nlp,nf,nd,nom; /* coefficients of l,l',F,D,Om */
        double s1,c1;         /* sine and cosine of xp */
        double s2,c2;         /* sine and cosine of yp */
        double s3,c3;         /* sine and cosine of ut1 */
    } x[]={
            {1,-1, 0,-2,-2,-2,  -0.05,   0.94,  -0.94, -0.05,  0.396, -0.078},
            {1,-2, 0,-2, 0,-1,   0.06,   0.64,  -0.64,  0.06,  0.195, -0.059},
            {1,-2, 0,-2, 0,-2,   0.30,   3.42,  -3.42,  0.30,  1.034, -0.314},
            {1, 0, 0,-2,-2,-1,   0.08,   0.78,  -0.78,  0.08,  0.224, -0.073},
            {1, 0, 0,-2,-2,-2,   0.46,   4.15,  -4.15,  0.45,  1.187, -0.387},
            {1,-1, 0,-2, 0,-1,   1.19,   4.96,  -4.96,  1.19,  0.966, -0.474},
            {1,-1, 0,-2, 0,-2,   6.24,  26.31, -26.31,  6.23,  5.118, -2.499},
            {1, 1, 0,-2,-2,-1,   0.24,   0.94,  -0.94,  0.24,  0.172, -0.090},
            {1, 1, 0,-2,-2,-2,   1.28,   4.99,  -4.99,  1.28,  0.911, -0.475},
            {1, 0, 0,-2, 0, 0,  -0.28,  -0.77,   0.77, -0.28, -0.093,  0.070},
            {1, 0, 0,-2, 0,-1,   9.22,  25.06, -25.06,  9.22,  3.025, -2.280},
            {1, 0, 0,-2, 0,-2,  48.82, 132.91,-132.90, 48.82, 16.020,-12.069},
            {1,-2, 0, 0, 0, 0,  -0.32,  -0.86,   0.86, -0.32, -0.103,  0.078},
            {1, 0, 0, 0,-2, 0,  -0.66,  -1.72,   1.72, -0.66, -0.194,  0.154},
            {1,-1, 0,-2, 2,-2,  -0.42,  -0.92,   0.92, -0.42, -0.083,  0.074},
            {1, 1, 0,-2, 0,-1,  -0.30,  -0.64,   0.64, -0.30, -0.057,  0.050},
            {1, 1, 0,-2, 0,-2,  -1.61,  -3.46,   3.46, -1.61, -0.308,  0.271},
            {1,-1, 0, 0, 0, 0,  -4.48,  -9.61,   9.61, -4.48, -0.856,  0.751},
            {1,-1, 0, 0, 0,-1,  -0.90,  -1.93,   1.93, -0.90, -0.172,  0.151},
            {1, 1, 0, 0,-2, 0,  -0.86,  -1.81,   1.81, -0.86, -0.161,  0.137},
            {1, 0,-1,-2, 2,-2,   1.54,   3.03,  -3.03,  1.54,  0.315, -0.189},
            {1, 0, 0,-2, 2,-1,  -0.29,  -0.58,   0.58, -0.29, -0.062,  0.035},
            {1, 0, 0,-2, 2,-2,  26.13,  51.25, -51.25, 26.13,  5.512, -3.095},
            {1, 0, 1,-2, 2,-2,  -0.22,  -0.42,   0.42, -0.22, -0.047,  0.025},
            {1, 0,-1, 0, 0, 0,  -0.61,  -1.20,   1.20, -0.61, -0.134,  0.070},
            {1, 0, 0, 0, 0, 1,   1.54,   3.00,  -3.00,  1.54,  0.348, -0.171},
            {1, 0, 0, 0, 0, 0, -77.48,-151.74, 151.74,-77.48,-17.620,  8.548},
            {1, 0, 0, 0, 0,-1, -10.52, -20.56,  20.56,-10.52, -2.392,  1.159},
            {1, 0, 0, 0, 0,-2,   0.23,   0.44,  -0.44,  0.23,  0.052, -0.025},
            {1, 0, 1, 0, 0, 0,  -0.61,  -1.19,   1.19, -0.61, -0.144,  0.065},
            {1, 0, 0, 2,-2, 2,  -1.09,  -2.11,   2.11, -1.09, -0.267,  0.111},
            {1,-1, 0, 0, 2, 0,  -0.69,  -1.43,   1.43, -0.69, -0.288,  0.043},
            {1, 1, 0, 0, 0, 0,  -3.46,  -7.28,   7.28, -3.46, -1.610,  0.187},
            {1, 1, 0, 0, 0,-1,  -0.69,  -1.44,   1.44, -0.69, -0.320,  0.037},
            {1, 0, 0, 0, 2, 0,  -0.37,  -1.06,   1.06, -0.37, -0.407, -0.005},
            {1, 2, 0, 0, 0, 0,  -0.17,  -0.51,   0.51, -0.17, -0.213, -0.005},
            {1, 0, 0, 2, 0, 2,  -1.10,  -3.42,   3.42, -1.09, -1.436, -0.037},
            {1, 0, 0, 2, 0, 1,  -0.70,  -2.19,   2.19, -0.70, -0.921, -0.023},
            {1, 0, 0, 2, 0, 0,  -0.15,  -0.46,   0.46, -0.15, -0.193, -0.005},
            {1, 1, 0, 2, 0, 2,  -0.03,  -0.59,   0.59, -0.03, -0.396, -0.024},
            {1, 1, 0, 2, 0, 1,  -0.02,  -0.38,   0.38, -0.02, -0.253, -0.015},
            {2,-3, 0,-2, 0,-2,  -0.49,  -0.04,   0.63,  0.24, -0.089, -0.011},
            {2,-1, 0,-2,-2,-2,  -1.33,  -0.17,   1.53,  0.68, -0.224, -0.032},
            {2,-2, 0,-2, 0,-2,  -6.08,  -1.61,   3.13,  3.35, -0.637, -0.177},
            {2, 0, 0,-2,-2,-2,  -7.59,  -2.05,   3.44,  4.23, -0.745, -0.222},
            {2, 0, 1,-2,-2,-2,  -0.52,  -0.14,   0.22,  0.29, -0.049, -0.015},
            {2,-1,-1,-2, 0,-2,   0.47,   0.11,  -0.10, -0.27,  0.033,  0.013},
            {2,-1, 0,-2, 0,-1,   2.12,   0.49,  -0.41, -1.23,  0.141,  0.058},
            {2,-1, 0,-2, 0,-2, -56.87, -12.93,  11.15, 32.88, -3.795, -1.556},
            {2,-1, 1,-2, 0,-2,  -0.54,  -0.12,   0.10,  0.31, -0.035, -0.015},
            {2, 1, 0,-2,-2,-2, -11.01,  -2.40,   1.89,  6.41, -0.698, -0.298},
            {2, 1, 1,-2,-2,-2,  -0.51,  -0.11,   0.08,  0.30, -0.032, -0.014},
            {2,-2, 0,-2, 2,-2,   0.98,   0.11,  -0.11, -0.58,  0.050,  0.022},
            {2, 0,-1,-2, 0,-2,   1.13,   0.11,  -0.13, -0.67,  0.056,  0.025},
            {2, 0, 0,-2, 0,-1,  12.32,   1.00,  -1.41, -7.31,  0.605,  0.266},
            {2, 0, 0,-2, 0,-2,-330.15, -26.96,  37.58,195.92,-16.195, -7.140},
            {2, 0, 1,-2, 0,-2,  -1.01,  -0.07,   0.11,  0.60, -0.049, -0.021},
            {2,-1, 0,-2, 2,-2,   2.47,  -0.28,  -0.44, -1.48,  0.111,  0.034},
            {2, 1, 0,-2, 0,-2,   9.40,  -1.44,  -1.88, -5.65,  0.425,  0.117},
            {2,-1, 0, 0, 0, 0,  -2.35,   0.37,   0.47,  1.41, -0.106, -0.029},
            {2,-1, 0, 0, 0,-1,  -1.04,   0.17,   0.21,  0.62, -0.047, -0.013},
            {2, 0,-1,-2, 2,-2,  -8.51,   3.50,   3.29,  5.11, -0.437, -0.019},
            {2, 0, 0,-2, 2,-2,-144.13,  63.56,  59.23, 86.56, -7.547, -0.159},
            {2, 0, 1,-2, 2,-2,   1.19,  -0.56,  -0.52, -0.72,  0.064,  0.000},
            {2, 0, 0, 0, 0, 1,   0.49,  -0.25,  -0.23, -0.29,  0.027, -0.001},
            {2, 0, 0, 0, 0, 0, -38.48,  19.14,  17.72, 23.11, -2.104,  0.041},
            {2, 0, 0, 0, 0,-1, -11.44,   5.75,   5.32,  6.87, -0.627,  0.015},
            {2, 0, 0, 0, 0,-2,  -1.24,   0.63,   0.58,  0.75, -0.068,  0.002},
            {2, 1, 0, 0, 0, 0,  -1.77,   1.79,   1.71,  1.04, -0.146,  0.037},
            {2, 1, 0, 0, 0,-1,  -0.77,   0.78,   0.75,  0.45, -0.064,  0.017},
            {2, 0, 0, 2, 0, 2,  -0.33,   0.62,   0.65,  0.19, -0.049,  0.018}
    };
    const double TURNAS=360.0*3600.0;
    const double mjd_j2000=51544.5;
    const double jc=36525.0;
    const int NT=(int)(sizeof(x)/sizeof(x[0]));
    double mjd_utc,ep[6];

    time2epoch(tutc,ep);
    mjd_utc=cal2mjd(ep);

    double t=(mjd_utc-mjd_j2000)/jc;
    double t2=t*t;
    double t3=t2*t;
    double t4=t3*t;
    double chi,l,lp,f,d,om;
    double dchi,dl,dlp,df,dd,dom;
    double arg,darg;
    int i;

    /* arguments in the following order: chi=GMST+PI,l,lp,F,D,Omega */
    chi=(67310.54841+(876600.0*3600+8640184.812866)*t+0.093104*t2-6.2E-6*t3)*15.0+648000.0;
    chi=fmod(chi,TURNAS)*AS2R;
    dchi=(876600.0*3600+8640184.812866+2*0.093104*t-3*6.2E-6*t2)*15.0;
    dchi=dchi*AS2R/jc;

    l=-0.00024470*t4+0.051635*t3+31.8792*t2+1717915923.2178*t+485868.249036;
    l=fmod(l,TURNAS)*AS2R;
    dl=-4*0.00024470*t3+3*0.051635*t2+2*31.8792*t+1717915923.2178;
    dl=dl*AS2R/jc;

    lp=-0.00001149*t4-0.000136*t3-0.5532*t2+129596581.0481*t+1287104.79305;
    lp=fmod(lp,TURNAS)*AS2R;
    dlp=-4*0.00001149*t3-3*0.000136*t2-2*0.5532*t+129596581.0481;
    dlp=dlp*AS2R/jc;

    f=0.00000417*t4-0.001037*t3-12.7512*t2+1739527262.8478*t+335779.526232;
    f=fmod(f,TURNAS)*AS2R;
    df=4*0.00000417*t3-3*0.001037*t2-2*12.7512*t+1739527262.8478;
    df=df*AS2R/jc;

    d=-0.00003169*t4+0.006593*t3-6.3706*t2+1602961601.2090*t+1072260.70369;
    d=fmod(d,TURNAS)*AS2R;
    dd=-4*0.00003169*t3+3*0.006593*t2-2*6.3706*t+1602961601.2090;
    dd=dd*AS2R/jc;

    om=-0.00005939*t4+0.007702*t3+7.4722*t2-6962890.2665*t+450160.398036;
    om=fmod(om,TURNAS)*AS2R;
    dom=-4*0.00005939*t3+3*0.007702*t2+2*7.4722*t-6962890.2665;
    dom=dom*AS2R/jc;

    /* compute diurnal/subdiurnal tidal effects on polar motion */
    for (i=0;i<NT;i++) {
        arg=darg=0.0;
        arg +=x[i].nchi*chi +x[i].n1*l +x[i].nlp*lp +x[i].nf*f +x[i].nd* d+x[i].nom* om;
        darg+=x[i].nchi*dchi+x[i].n1*dl+x[i].nlp*dlp+x[i].nf*df+x[i].nd*dd+x[i].nom*dom;
        arg=fmod(arg,2.0*PI);

        cor[0]+=x[i].c1*cos(arg)+x[i].s1*sin(arg);
        cor[1]+=x[i].c2*cos(arg)+x[i].s2*sin(arg);
        cor[2]+=x[i].c3*cos(arg)+x[i].s3*sin(arg);
        cor[3]-=(-x[i].c3*sin(arg)+x[i].s3*cos(arg))*darg;
    }
    cor[0]*=1E-6; /* xp, arcsecond (") */
    cor[1]*=1E-6; /* yp, arcsecond (") */
    cor[2]*=1E-6; /* ut1_utc, second (s) */
    cor[3]*=1E-6; /* lod, second (s) */
}
/* evaluate the model of subdiurnal libration in the axial component of ratation
 * expressed by UT1 and LOD-----------------------------------------*/
extern void utlibr(gtime_t tutc, double *cor)
{
    static const struct {
        int nchi;             /* coefficients of GMST+PI */
        int n1,nlp,nf,nd,nom; /* coefficients of l,l',F,D,Om */
        double s1,c1;         /* sine and cosine of xp */
        double s2,c2;         /* sine and cosine of yp */
        double s3,c3;         /* sine and cosine of ut1 */
    } x[]={
            {2,-2, 0,-2, 0,-2,0.5377239, 0.05,-0.03, -0.3, -0.6},
            {2, 0, 0,-2,-2,-2,0.5363232, 0.06,-0.03, -0.4, -0.7},
            {2,-1, 0,-2, 0,-2,0.5274312, 0.35,-0.20, -2.4, -4.1},
            {2, 1, 0,-2,-2,-2,0.5260835, 0.07,-0.04, -0.5, -0.8},
            {2, 0, 0,-2, 0,-1,0.5175645,-0.07, 0.04,  0.5,  0.8},
            {2, 0, 0,-2, 0,-2,0.5175251, 1.75,-1.01,-12.2,-21.3},
            {2, 1, 0,-2, 0,-2,0.5079842,-0.05, 0.03,  0.3,  0.6},
            {2, 0,-1,-2, 2,-2,0.5006854, 0.04,-0.03, -0.3, -0.6},
            {2, 0, 0,-2, 2,-2,0.5000000, 0.76,-0.44, -5.5, -9.6},
            {2, 0, 0, 0, 0, 0,0.4986348, 0.21,-0.12, -1.5, -2.6},
            {2, 0, 0, 0, 0,-1,0.4985982, 0.06,-0.04, -0.4, -0.8}
    };
    const double TURNAS=360.0*3600.0;
    const double mjd_j2000=51544.5;
    const double jc=36525.0;
    const int NT=(int)(sizeof(x)/sizeof(x[0]));
    double mjd_utc,ep[6];

    time2epoch(tutc,ep);
    mjd_utc=cal2mjd(ep);

    double t=(mjd_utc-mjd_j2000)/jc;
    double t2=t*t;
    double t3=t2*t;
    double t4=t3*t;

    double chi,l,lp,f,d,om;
    double arg;
    int i;

    /* arguments in the following order: chi=GMST+PI,l,lp,F,D,Omega */
    chi=(67310.54841+(876600.0*3600+8640184.812866)*t+0.093104*t2-6.2E-6*t3)*15.0+648000.0;
    chi=fmod(chi,TURNAS)*AS2R;

    l=-0.00024470*t4+0.051635*t3+31.8792*t2+1717915923.2178*t+485868.249036;
    l=fmod(l,TURNAS)*AS2R;

    lp=-0.00001149*t4-0.000136*t3-0.5532*t2+129596581.0481*t+1287104.79305;
    lp=fmod(lp,TURNAS)*AS2R;

    f=0.00000417*t4-0.001037*t3-12.7512*t2+1739527262.8478*t+335779.526232;
    f=fmod(f,TURNAS)*AS2R;

    d=-0.00003169*t4+0.006593*t3-6.3706*t2+1602961601.2090*t+1072260.70369;
    d=fmod(d,TURNAS)*AS2R;

    om=-0.00005939*t4+0.007702*t3+7.4722*t2-6962890.2665*t+450160.398036;
    om=fmod(om,TURNAS)*AS2R;

    /* compute model of subdiurnal libration in the axial component of ratation */
    for (i=0;i<NT;i++) {
        arg=0.0;
        arg+=x[i].nchi*chi+x[i].n1*l+x[i].nlp*lp+x[i].nf*f+x[i].nd*d+x[i].nom*om;
        arg=fmod(arg,2.0*PI);
        cor[0]+=x[i].c1*cos(arg)+x[i].s1*sin(arg);
        cor[1]+=x[i].c2*cos(arg)+x[i].s2*sin(arg);
    }
    cor[0]*=1E-6; /* ut1_utc, second (s) */
    cor[1]*=1E-6; /* lod, second (s) */
}
/* provide the diurnal lunisolar effect on polar motion ("), in time domain---
 * IERS conventions 2010-----------------------------------------------------*/
extern void pmsdnut2(gtime_t tutc, double *cor)
{
    static const struct {
        int nchi;             /* coefficients of GMST+PI */
        int n1,nlp,nf,nd,nom; /* coefficients of l,l',F,D,Om */
        double s1,c1;         /* sine and cosine of xp */
        double s2,c2;         /* sine and cosine of yp */
        double s3,c3;         /* sine and cosine of ut1 */
    } x[]={
            {1,-1,0,-2, 0,-1, -0.44, 0.25,-0.25, -0.44},
            {1,-1,0,-2, 0,-2, -2.31, 1.32,-1.32, -2.31},
            {1, 1,0,-2,-2,-2, -0.44, 0.25,-0.25, -0.44},
            {1, 0,0,-2, 0,-1, -2.14, 1.23,-1.23, -2.14},
            {1, 0,0,-2, 0,-2,-11.36, 6.52,-6.52,-11.36},
            {1,-1,0, 0, 0, 0,  0.84,-0.48, 0.48,  0.84},
            {1, 0,0,-2, 2,-2, -4.76, 2.73,-2.73, -4.76},
            {1, 0,0, 0, 0, 0, 14.27,-8.19, 8.19, 14.27},
            {1, 0,0, 0, 0,-1,  1.93,-1.11, 1.11,  1.93},
            {1, 1,0, 0, 0, 0,  0.76,-0.43, 0.43,  0.76}
    };
    const double TURNAS=360.0*3600.0;
    const double mjd_j2000=51544.5;
    const double jc=36525.0;
    const int NT=(int)(sizeof(x)/sizeof(x[0]));
    double mjd_utc,ep[6];

    time2epoch(tutc,ep);
    mjd_utc=cal2mjd(ep);

    double t=(mjd_utc-mjd_j2000)/jc;
    double t2=t*t;
    double t3=t2*t;
    double t4=t3*t;

    double chi,l,lp,f,d,om;
    double arg;
    int i;

    /* arguments in the following order: chi=GMST+PI,l,lp,F,D,Omega */
    chi=(67310.54841+(876600.0*3600+8640184.812866)*t+0.093104*t2-6.2E-6*t3)*15.0+648000.0;
    chi=fmod(chi,TURNAS)*AS2R;

    l=-0.00024470*t4+0.051635*t3+31.8792*t2+1717915923.2178*t+485868.249036;
    l=fmod(l,TURNAS)*AS2R;

    lp=-0.00001149*t4-0.000136*t3-0.5532*t2+129596581.0481*t+1287104.79305;
    lp=fmod(lp,TURNAS)*AS2R;

    f=0.00000417*t4-0.001037*t3-12.7512*t2+1739527262.8478*t+335779.526232;
    f=fmod(f,TURNAS)*AS2R;

    d=-0.00003169*t4+0.006593*t3-6.3706*t2+1602961601.2090*t+1072260.70369;
    d=fmod(d,TURNAS)*AS2R;

    om=-0.00005939*t4+0.007702*t3+7.4722*t2-6962890.2665*t+450160.398036;
    om=fmod(om,TURNAS)*AS2R;

    /* compute diurnal lunisolar effect on polar motion (") */
    for (i=0;i<NT;i++) {
        arg=0.0;
        arg+=x[i].nchi*chi+x[i].n1*l+x[i].nlp*lp+x[i].nf*f+x[i].nd*d+x[i].nom*om;
        arg=fmod(arg,2.0*PI);
        cor[0]+=x[i].c1*cos(arg)+x[i].s1*sin(arg);
        cor[1]+=x[i].c2*cos(arg)+x[i].s2*sin(arg);
    }
    cor[0]*=1E-6; /* xp, arcsecond (") */
    cor[1]*=1E-6; /* yp, arcsecond (") */
}
/* get orbit state vector-----------------------------------------------------*/
extern void orbitgetx(const satorbit_t *orbit, double *x)
{
    /* position/velocity */
    matcpy(x,orbit->x,1,6);

    /* srp parameters: D0,Dc,Ds,Dc2,Ds2,Dc4,Ds4,Y0,Yc,Ys,B0,Bc,Bs */
    x[GIS_D0 ]=orbit->fmdl.sp.D0;
    x[GIS_DC ]=orbit->fmdl.sp.Dc;
    x[GIS_DS ]=orbit->fmdl.sp.Ds;
    x[GIS_DC2]=orbit->fmdl.sp.Dc2;
    x[GIS_DS2]=orbit->fmdl.sp.Ds2;
    x[GIS_DC4]=orbit->fmdl.sp.Dc4;
    x[GIS_DS4]=orbit->fmdl.sp.Ds4;
    x[GIS_Y0 ]=orbit->fmdl.sp.Y0;
    x[GIS_YC ]=orbit->fmdl.sp.Yc;
    x[GIS_YS ]=orbit->fmdl.sp.Ys;
    x[GIS_B0 ]=orbit->fmdl.sp.B0;
    x[GIS_BC ]=orbit->fmdl.sp.Bc;
    x[GIS_BS ]=orbit->fmdl.sp.Bs;
}
/* set orbit state vector-----------------------------------------------------*/
extern void orbitsetx(const double *x, satorbit_t *orbit)
{
    /* position/velocity */
    matcpy(orbit->x,x,1,GNX);

    /* srp parameters: D0,Dc,Ds,Dc2,Ds2,Dc4,Ds4,Y0,Yc,Ys,B0,Bc,Bs */
    orbit->fmdl.sp.D0 =x[GIS_D0 ];
    orbit->fmdl.sp.Dc =x[GIS_DC ];
    orbit->fmdl.sp.Ds =x[GIS_DS ];
    orbit->fmdl.sp.Dc2=x[GIS_DC2];
    orbit->fmdl.sp.Ds2=x[GIS_DS2];
    orbit->fmdl.sp.Dc4=x[GIS_DC4];
    orbit->fmdl.sp.Ds4=x[GIS_DS4];
    orbit->fmdl.sp.Y0 =x[GIS_Y0 ];
    orbit->fmdl.sp.Yc =x[GIS_YC ];
    orbit->fmdl.sp.Ys =x[GIS_YS ];
    orbit->fmdl.sp.B0 =x[GIS_B0 ];
    orbit->fmdl.sp.Bc =x[GIS_BC ];
    orbit->fmdl.sp.Bs =x[GIS_BS ];
}

#define NX			(6+6*6)				/* number of states */
#define TSTEP		1.0					/* integration step time (sec) */

/* geopotential acceleration and partial derivatives with j2 -----------------*/
static void sataccel(const double *r, double *a, double *dadr)
{
    static const double GMe=3.986004415E+14;
    static const double Re=6378136.3;
    static const double J2=0.001082636;
    double k=1.5*J2*Re*Re;
    double r2,r3,p1,p2,daxdx,daydy,daxdy,daxdz,daydz;

    r2=dot(r,r,3); r3=r2*sqrt(r2);
    p1=1.0-5.0*r[2]*r[2]/r2;
    p2=3.0+5.0*k/r2-35.0*k*r[2]*r[2]/(r2*r2);
    a[0]=-GMe/r3*(r[0]+k/r2*p1*r[0]);
    a[1]=-GMe/r3*(r[1]+k/r2*p1*r[1]);
    a[2]=-GMe/r3*(r[2]+k/r2*(p1+2.0)*r[2]);
    daxdx=GMe/(r2*r3)*(r[0]*r[0]*p2-k*p1-r2);
    daydy=GMe/(r2*r3)*(r[1]*r[1]*p2-k*p1-r2);
    daxdy=GMe/(r2*r3)*r[0]*r[1]*p2;
    daxdz=GMe/(r2*r3)*r[0]*r[2]*(p2+10.0*k/r2);
    daydz=GMe/(r2*r3)*r[1]*r[2]*(p2+10.0*k/r2);
    dadr[0]=daxdx;
    dadr[1]=dadr[3]=daxdy;
    dadr[2]=dadr[6]=daxdz;
    dadr[4]=daydy;
    dadr[5]=dadr[7]=daydz;
    dadr[8]=-daxdx-daydy;
}
/* ordinary differential equation --------------------------------------------*/
static void deq(const double *U, double t, const double *x, double *xdot)
{
    int i,j;
    double Ut[9],r[3],a[3],Ut_a[3],dadr[9],Ut_dadr[9];

    matmul("NN",3,1,3,1.0,U,x,0.0,r);
    sataccel(r,a,dadr);
    matmul("TN",3,1,3,1.0,U,a,0.0,Ut_a);
    matmul("TN",3,3,3,1.0,U,dadr,0.0,Ut_dadr);
    matmul("NN",3,3,3,1.0,Ut_dadr,U,0.0,dadr);

    for (i=0;i<3;i++) {
        xdot[i]=x[i+3];
        xdot[i+3]=Ut_a[i];
    }
    for (i=0;i<9;i++) {
        xdot[i+6]=x[i+15];
        xdot[i+24]=x[i+33];
    }
    matmul("NN",3,3,3,1.0,dadr,x+6,0.0,xdot+15);
    matmul("NN",3,3,3,1.0,dadr,x+24,0.0,xdot+33);
}
/* numerical integration -----------------------------------------------------*/
static void rk4(const double *U, double t, double *x)
{
    int i;
    double tt,k1[NX],k2[NX],k3[NX],k4[NX],w[NX];

    for (tt=t<0.0?-TSTEP:TSTEP;fabs(t)>1E-9;t-=tt) {
        if (fabs(t)<TSTEP) tt=t;
        deq(U,tt+ 0.0,x,k1); for (i=0;i<NX;i++) w[i]=x[i]+k1[i]*tt/2.0;
        deq(U,tt+tt/2,w,k2); for (i=0;i<NX;i++) w[i]=x[i]+k2[i]*tt/2.0;
        deq(U,tt+tt/2,w,k3); for (i=0;i<NX;i++) w[i]=x[i]+k3[i]*tt;
        deq(U,tt+  tt,w,k4);
        for (i=0;i<NX;i++) x[i]=x[i]+(k1[i]+2.0*k2[i]+2.0*k3[i]+k4[i])*tt/6.0;
    }
}
/* state transition model - j2 perturbation ----------------------------------*/
extern void orbintj2(gtime_t tutc, const double *erpv, double dt, const double *x0, double *x, double *Phi)
{
    static const int index[]={
            0,1,2,9,10,11, 3,4,5,12,13,14, 6,7,8,15,16,17,
            18,19,20,27,28,29, 21,22,23,30,31,32, 24,25,26,33,34,35
    };
    int i;
    double xx[NX],U[9];

    eci2ecef(tutc,erpv,U,NULL,NULL);

    for (i=0;i<6;i++) xx[i]=x0[i];
    memset(xx+6,0,9*sizeof(double));
    xx[6+0]=1.0;
    xx[6+4]=1.0;
    xx[6+8]=1.0;

    memset(xx+15,0,9*sizeof(double));
    memset(xx+24,0,9*sizeof(double));
    memset(xx+33,0,9*sizeof(double));
    xx[33+0]=1.0;
    xx[33+4]=1.0;
    xx[33+8]=1.0;

    rk4(U,dt,xx);

    for (i=0;i<6;i++) x[i]=xx[i];
    for (i=0;i<36;i++) Phi[i]=xx[index[i]+6];
}
extern void orbintj2_U(gtime_t tutc, const double *U, double dt, const double *x0, double *x, double *Phi)
{
    static const int index[]={
            0,1,2,9,10,11, 3,4,5,12,13,14, 6,7,8,15,16,17,
            18,19,20,27,28,29, 21,22,23,30,31,32, 24,25,26,33,34,35
    };
    int i;
    double xx[NX];

    for (i=0;i<6;i++) xx[i]=x0[i];
    memset(xx+6,0,9*sizeof(double));
    xx[6+0]=1.0;
    xx[6+4]=1.0;
    xx[6+8]=1.0;

    memset(xx+15,0,9*sizeof(double));
    memset(xx+24,0,9*sizeof(double));
    memset(xx+33,0,9*sizeof(double));
    xx[33+0]=1.0;
    xx[33+4]=1.0;
    xx[33+8]=1.0;

    rk4(U,dt,xx);

    for (i=0;i<6;i++) x[i]=xx[i];
    for (i=0;i<36;i++) Phi[i]=xx[index[i]+6];
}
